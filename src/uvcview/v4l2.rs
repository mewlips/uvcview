#[allow(dead_code)];
#[allow(non_camel_case_types)];
/* automatically generated by rust-bindgen */

use std::default::Default;
use std::libc::{c_int,c_schar,c_uint,c_ulong,c_void};
use std::libc::types::os::common::posix01::{timespec,timeval};

//#define VIDEO_MAX_FRAME 32
pub static VIDEO_MAX_FRAME: c_ulong = 0x20;
//#define VIDEO_MAX_PLANES 8
pub static VIDEO_MAX_PLANES: c_ulong = 0x8;
//#define VID_TYPE_CAPTURE 1 /* Can capture */
pub static VID_TYPE_CAPTURE: c_ulong = 0x1;
//#define VID_TYPE_TUNER 2 /* Can tune */
pub static VID_TYPE_TUNER: c_ulong = 0x2;
//#define VID_TYPE_TELETEXT 4 /* Does teletext */
pub static VID_TYPE_TELETEXT: c_ulong = 0x4;
//#define VID_TYPE_OVERLAY 8 /* Overlay onto frame buffer */
pub static VID_TYPE_OVERLAY: c_ulong = 0x8;
//#define VID_TYPE_CHROMAKEY 16 /* Overlay by chromakey */
pub static VID_TYPE_CHROMAKEY: c_ulong = 0x10;
//#define VID_TYPE_CLIPPING 32 /* Can clip */
pub static VID_TYPE_CLIPPING: c_ulong = 0x20;
//#define VID_TYPE_FRAMERAM 64 /* Uses the frame buffer memory */
pub static VID_TYPE_FRAMERAM: c_ulong = 0x40;
//#define VID_TYPE_SCALES 128 /* Scalable */
pub static VID_TYPE_SCALES: c_ulong = 0x80;
//#define VID_TYPE_MONOCHROME 256 /* Monochrome only */
pub static VID_TYPE_MONOCHROME: c_ulong = 0x100;
//#define VID_TYPE_SUBCAPTURE 512 /* Can capture subareas of the image */
pub static VID_TYPE_SUBCAPTURE: c_ulong = 0x200;
//#define VID_TYPE_MPEG_DECODER 1024 /* Can decode MPEG streams */
pub static VID_TYPE_MPEG_DECODER: c_ulong = 0x400;
//#define VID_TYPE_MPEG_ENCODER 2048 /* Can encode MPEG streams */
pub static VID_TYPE_MPEG_ENCODER: c_ulong = 0x800;
//#define VID_TYPE_MJPEG_DECODER 4096 /* Can decode MJPEG streams */
pub static VID_TYPE_MJPEG_DECODER: c_ulong = 0x1000;
//#define VID_TYPE_MJPEG_ENCODER 8192 /* Can encode MJPEG streams */
pub static VID_TYPE_MJPEG_ENCODER: c_ulong = 0x2000;
//#define V4L2_CAP_VIDEO_CAPTURE 0x00000001 /* Is a video capture device */
pub static V4L2_CAP_VIDEO_CAPTURE: c_ulong = 0x1;
//#define V4L2_CAP_VIDEO_OUTPUT 0x00000002 /* Is a video output device */
pub static V4L2_CAP_VIDEO_OUTPUT: c_ulong = 0x2;
//#define V4L2_CAP_VIDEO_OVERLAY 0x00000004 /* Can do video overlay */
pub static V4L2_CAP_VIDEO_OVERLAY: c_ulong = 0x4;
//#define V4L2_CAP_VBI_CAPTURE 0x00000010 /* Is a raw VBI capture device */
pub static V4L2_CAP_VBI_CAPTURE: c_ulong = 0x10;
//#define V4L2_CAP_VBI_OUTPUT 0x00000020 /* Is a raw VBI output device */
pub static V4L2_CAP_VBI_OUTPUT: c_ulong = 0x20;
//#define V4L2_CAP_SLICED_VBI_CAPTURE 0x00000040 /* Is a sliced VBI capture device */
pub static V4L2_CAP_SLICED_VBI_CAPTURE: c_ulong = 0x40;
//#define V4L2_CAP_SLICED_VBI_OUTPUT 0x00000080 /* Is a sliced VBI output device */
pub static V4L2_CAP_SLICED_VBI_OUTPUT: c_ulong = 0x80;
//#define V4L2_CAP_RDS_CAPTURE 0x00000100 /* RDS data capture */
pub static V4L2_CAP_RDS_CAPTURE: c_ulong = 0x100;
//#define V4L2_CAP_VIDEO_OUTPUT_OVERLAY 0x00000200 /* Can do video output overlay */
pub static V4L2_CAP_VIDEO_OUTPUT_OVERLAY: c_ulong = 0x200;
//#define V4L2_CAP_HW_FREQ_SEEK 0x00000400 /* Can do hardware frequency seek */
pub static V4L2_CAP_HW_FREQ_SEEK: c_ulong = 0x400;
//#define V4L2_CAP_RDS_OUTPUT 0x00000800 /* Is an RDS encoder */
pub static V4L2_CAP_RDS_OUTPUT: c_ulong = 0x800;
//#define V4L2_CAP_VIDEO_CAPTURE_MPLANE 0x00001000
pub static V4L2_CAP_VIDEO_CAPTURE_MPLANE: c_ulong = 0x1000;
//#define V4L2_CAP_VIDEO_OUTPUT_MPLANE 0x00002000
pub static V4L2_CAP_VIDEO_OUTPUT_MPLANE: c_ulong = 0x2000;
//#define V4L2_CAP_VIDEO_M2M_MPLANE 0x00004000
pub static V4L2_CAP_VIDEO_M2M_MPLANE: c_ulong = 0x4000;
//#define V4L2_CAP_VIDEO_M2M 0x00008000
pub static V4L2_CAP_VIDEO_M2M: c_ulong = 0x8000;
//#define V4L2_CAP_TUNER 0x00010000 /* has a tuner */
pub static V4L2_CAP_TUNER: c_ulong = 0x10000;
//#define V4L2_CAP_AUDIO 0x00020000 /* has audio support */
pub static V4L2_CAP_AUDIO: c_ulong = 0x20000;
//#define V4L2_CAP_RADIO 0x00040000 /* is a radio device */
pub static V4L2_CAP_RADIO: c_ulong = 0x40000;
//#define V4L2_CAP_MODULATOR 0x00080000 /* has a modulator */
pub static V4L2_CAP_MODULATOR: c_ulong = 0x80000;
//#define V4L2_CAP_READWRITE 0x01000000 /* read/write systemcalls */
pub static V4L2_CAP_READWRITE: c_ulong = 0x1000000;
//#define V4L2_CAP_ASYNCIO 0x02000000 /* async I/O */
pub static V4L2_CAP_ASYNCIO: c_ulong = 0x2000000;
//#define V4L2_CAP_STREAMING 0x04000000 /* streaming I/O ioctls */
pub static V4L2_CAP_STREAMING: c_ulong = 0x4000000;
//#define V4L2_CAP_DEVICE_CAPS 0x80000000 /* sets device capabilities field */
pub static V4L2_CAP_DEVICE_CAPS: c_ulong = 0x80000000;
//#define V4L2_PIX_FMT_RGB332 v4l2_fourcc('R', 'G', 'B', '1') /* 8 RGB-3-3-2 */
pub static V4L2_PIX_FMT_RGB332: c_ulong = 0x31424752;
//#define V4L2_PIX_FMT_RGB444 v4l2_fourcc('R', '4', '4', '4') /* 16 xxxxrrrr ggggbbbb */
pub static V4L2_PIX_FMT_RGB444: c_ulong = 0x34343452;
//#define V4L2_PIX_FMT_RGB555 v4l2_fourcc('R', 'G', 'B', 'O') /* 16 RGB-5-5-5 */
pub static V4L2_PIX_FMT_RGB555: c_ulong = 0x4f424752;
//#define V4L2_PIX_FMT_RGB565 v4l2_fourcc('R', 'G', 'B', 'P') /* 16 RGB-5-6-5 */
pub static V4L2_PIX_FMT_RGB565: c_ulong = 0x50424752;
//#define V4L2_PIX_FMT_RGB555X v4l2_fourcc('R', 'G', 'B', 'Q') /* 16 RGB-5-5-5 BE */
pub static V4L2_PIX_FMT_RGB555X: c_ulong = 0x51424752;
//#define V4L2_PIX_FMT_RGB565X v4l2_fourcc('R', 'G', 'B', 'R') /* 16 RGB-5-6-5 BE */
pub static V4L2_PIX_FMT_RGB565X: c_ulong = 0x52424752;
//#define V4L2_PIX_FMT_BGR666 v4l2_fourcc('B', 'G', 'R', 'H') /* 18 BGR-6-6-6 */
pub static V4L2_PIX_FMT_BGR666: c_ulong = 0x48524742;
//#define V4L2_PIX_FMT_BGR24 v4l2_fourcc('B', 'G', 'R', '3') /* 24 BGR-8-8-8 */
pub static V4L2_PIX_FMT_BGR24: c_ulong = 0x33524742;
//#define V4L2_PIX_FMT_RGB24 v4l2_fourcc('R', 'G', 'B', '3') /* 24 RGB-8-8-8 */
pub static V4L2_PIX_FMT_RGB24: c_ulong = 0x33424752;
//#define V4L2_PIX_FMT_BGR32 v4l2_fourcc('B', 'G', 'R', '4') /* 32 BGR-8-8-8-8 */
pub static V4L2_PIX_FMT_BGR32: c_ulong = 0x34524742;
//#define V4L2_PIX_FMT_RGB32 v4l2_fourcc('R', 'G', 'B', '4') /* 32 RGB-8-8-8-8 */
pub static V4L2_PIX_FMT_RGB32: c_ulong = 0x34424752;
//#define V4L2_PIX_FMT_GREY v4l2_fourcc('G', 'R', 'E', 'Y') /* 8 Greyscale */
pub static V4L2_PIX_FMT_GREY: c_ulong = 0x59455247;
//#define V4L2_PIX_FMT_Y4 v4l2_fourcc('Y', '0', '4', ' ') /* 4 Greyscale */
pub static V4L2_PIX_FMT_Y4: c_ulong = 0x20343059;
//#define V4L2_PIX_FMT_Y6 v4l2_fourcc('Y', '0', '6', ' ') /* 6 Greyscale */
pub static V4L2_PIX_FMT_Y6: c_ulong = 0x20363059;
//#define V4L2_PIX_FMT_Y10 v4l2_fourcc('Y', '1', '0', ' ') /* 10 Greyscale */
pub static V4L2_PIX_FMT_Y10: c_ulong = 0x20303159;
//#define V4L2_PIX_FMT_Y12 v4l2_fourcc('Y', '1', '2', ' ') /* 12 Greyscale */
pub static V4L2_PIX_FMT_Y12: c_ulong = 0x20323159;
//#define V4L2_PIX_FMT_Y16 v4l2_fourcc('Y', '1', '6', ' ') /* 16 Greyscale */
pub static V4L2_PIX_FMT_Y16: c_ulong = 0x20363159;
//#define V4L2_PIX_FMT_Y10BPACK v4l2_fourcc('Y', '1', '0', 'B') /* 10 Greyscale bit-packed */
pub static V4L2_PIX_FMT_Y10BPACK: c_ulong = 0x42303159;
//#define V4L2_PIX_FMT_PAL8 v4l2_fourcc('P', 'A', 'L', '8') /* 8 8-bit palette */
pub static V4L2_PIX_FMT_PAL8: c_ulong = 0x384c4150;
//#define V4L2_PIX_FMT_YVU410 v4l2_fourcc('Y', 'V', 'U', '9') /* 9 YVU 4:1:0 */
pub static V4L2_PIX_FMT_YVU410: c_ulong = 0x39555659;
//#define V4L2_PIX_FMT_YVU420 v4l2_fourcc('Y', 'V', '1', '2') /* 12 YVU 4:2:0 */
pub static V4L2_PIX_FMT_YVU420: c_ulong = 0x32315659;
//#define V4L2_PIX_FMT_YUYV v4l2_fourcc('Y', 'U', 'Y', 'V') /* 16 YUV 4:2:2 */
pub static V4L2_PIX_FMT_YUYV: c_ulong = 0x56595559;
//#define V4L2_PIX_FMT_YYUV v4l2_fourcc('Y', 'Y', 'U', 'V') /* 16 YUV 4:2:2 */
pub static V4L2_PIX_FMT_YYUV: c_ulong = 0x56555959;
//#define V4L2_PIX_FMT_YVYU v4l2_fourcc('Y', 'V', 'Y', 'U') /* 16 YVU 4:2:2 */
pub static V4L2_PIX_FMT_YVYU: c_ulong = 0x55595659;
//#define V4L2_PIX_FMT_UYVY v4l2_fourcc('U', 'Y', 'V', 'Y') /* 16 YUV 4:2:2 */
pub static V4L2_PIX_FMT_UYVY: c_ulong = 0x59565955;
//#define V4L2_PIX_FMT_VYUY v4l2_fourcc('V', 'Y', 'U', 'Y') /* 16 YUV 4:2:2 */
pub static V4L2_PIX_FMT_VYUY: c_ulong = 0x59555956;
//#define V4L2_PIX_FMT_YUV422P v4l2_fourcc('4', '2', '2', 'P') /* 16 YVU422 planar */
pub static V4L2_PIX_FMT_YUV422P: c_ulong = 0x50323234;
//#define V4L2_PIX_FMT_YUV411P v4l2_fourcc('4', '1', '1', 'P') /* 16 YVU411 planar */
pub static V4L2_PIX_FMT_YUV411P: c_ulong = 0x50313134;
//#define V4L2_PIX_FMT_Y41P v4l2_fourcc('Y', '4', '1', 'P') /* 12 YUV 4:1:1 */
pub static V4L2_PIX_FMT_Y41P: c_ulong = 0x50313459;
//#define V4L2_PIX_FMT_YUV444 v4l2_fourcc('Y', '4', '4', '4') /* 16 xxxxyyyy uuuuvvvv */
pub static V4L2_PIX_FMT_YUV444: c_ulong = 0x34343459;
//#define V4L2_PIX_FMT_YUV555 v4l2_fourcc('Y', 'U', 'V', 'O') /* 16 YUV-5-5-5 */
pub static V4L2_PIX_FMT_YUV555: c_ulong = 0x4f565559;
//#define V4L2_PIX_FMT_YUV565 v4l2_fourcc('Y', 'U', 'V', 'P') /* 16 YUV-5-6-5 */
pub static V4L2_PIX_FMT_YUV565: c_ulong = 0x50565559;
//#define V4L2_PIX_FMT_YUV32 v4l2_fourcc('Y', 'U', 'V', '4') /* 32 YUV-8-8-8-8 */
pub static V4L2_PIX_FMT_YUV32: c_ulong = 0x34565559;
//#define V4L2_PIX_FMT_YUV410 v4l2_fourcc('Y', 'U', 'V', '9') /* 9 YUV 4:1:0 */
pub static V4L2_PIX_FMT_YUV410: c_ulong = 0x39565559;
//#define V4L2_PIX_FMT_YUV420 v4l2_fourcc('Y', 'U', '1', '2') /* 12 YUV 4:2:0 */
pub static V4L2_PIX_FMT_YUV420: c_ulong = 0x32315559;
//#define V4L2_PIX_FMT_HI240 v4l2_fourcc('H', 'I', '2', '4') /* 8 8-bit color */
pub static V4L2_PIX_FMT_HI240: c_ulong = 0x34324948;
//#define V4L2_PIX_FMT_HM12 v4l2_fourcc('H', 'M', '1', '2') /* 8 YUV 4:2:0 16x16 macroblocks */
pub static V4L2_PIX_FMT_HM12: c_ulong = 0x32314d48;
//#define V4L2_PIX_FMT_M420 v4l2_fourcc('M', '4', '2', '0') /* 12 YUV 4:2:0 2 lines y, 1 line uv interleaved */
pub static V4L2_PIX_FMT_M420: c_ulong = 0x3032344d;
//#define V4L2_PIX_FMT_NV12 v4l2_fourcc('N', 'V', '1', '2') /* 12 Y/CbCr 4:2:0 */
pub static V4L2_PIX_FMT_NV12: c_ulong = 0x3231564e;
//#define V4L2_PIX_FMT_NV21 v4l2_fourcc('N', 'V', '2', '1') /* 12 Y/CrCb 4:2:0 */
pub static V4L2_PIX_FMT_NV21: c_ulong = 0x3132564e;
//#define V4L2_PIX_FMT_NV16 v4l2_fourcc('N', 'V', '1', '6') /* 16 Y/CbCr 4:2:2 */
pub static V4L2_PIX_FMT_NV16: c_ulong = 0x3631564e;
//#define V4L2_PIX_FMT_NV61 v4l2_fourcc('N', 'V', '6', '1') /* 16 Y/CrCb 4:2:2 */
pub static V4L2_PIX_FMT_NV61: c_ulong = 0x3136564e;
//#define V4L2_PIX_FMT_NV24 v4l2_fourcc('N', 'V', '2', '4') /* 24 Y/CbCr 4:4:4 */
pub static V4L2_PIX_FMT_NV24: c_ulong = 0x3432564e;
//#define V4L2_PIX_FMT_NV42 v4l2_fourcc('N', 'V', '4', '2') /* 24 Y/CrCb 4:4:4 */
pub static V4L2_PIX_FMT_NV42: c_ulong = 0x3234564e;
//#define V4L2_PIX_FMT_NV12M v4l2_fourcc('N', 'M', '1', '2') /* 12 Y/CbCr 4:2:0 */
pub static V4L2_PIX_FMT_NV12M: c_ulong = 0x32314d4e;
//#define V4L2_PIX_FMT_NV21M v4l2_fourcc('N', 'M', '2', '1') /* 21 Y/CrCb 4:2:0 */
pub static V4L2_PIX_FMT_NV21M: c_ulong = 0x31324d4e;
//#define V4L2_PIX_FMT_NV12MT v4l2_fourcc('T', 'M', '1', '2') /* 12 Y/CbCr 4:2:0 64x32 macroblocks */
pub static V4L2_PIX_FMT_NV12MT: c_ulong = 0x32314d54;
//#define V4L2_PIX_FMT_NV12MT_16X16 v4l2_fourcc('V', 'M', '1', '2') /* 12 Y/CbCr 4:2:0 16x16 macroblocks */
pub static V4L2_PIX_FMT_NV12MT_16X16: c_ulong = 0x32314d56;
//#define V4L2_PIX_FMT_YUV420M v4l2_fourcc('Y', 'M', '1', '2') /* 12 YUV420 planar */
pub static V4L2_PIX_FMT_YUV420M: c_ulong = 0x32314d59;
//#define V4L2_PIX_FMT_YVU420M v4l2_fourcc('Y', 'M', '2', '1') /* 12 YVU420 planar */
pub static V4L2_PIX_FMT_YVU420M: c_ulong = 0x31324d59;
//#define V4L2_PIX_FMT_SBGGR8 v4l2_fourcc('B', 'A', '8', '1') /* 8 BGBG.. GRGR.. */
pub static V4L2_PIX_FMT_SBGGR8: c_ulong = 0x31384142;
//#define V4L2_PIX_FMT_SGBRG8 v4l2_fourcc('G', 'B', 'R', 'G') /* 8 GBGB.. RGRG.. */
pub static V4L2_PIX_FMT_SGBRG8: c_ulong = 0x47524247;
//#define V4L2_PIX_FMT_SGRBG8 v4l2_fourcc('G', 'R', 'B', 'G') /* 8 GRGR.. BGBG.. */
pub static V4L2_PIX_FMT_SGRBG8: c_ulong = 0x47425247;
//#define V4L2_PIX_FMT_SRGGB8 v4l2_fourcc('R', 'G', 'G', 'B') /* 8 RGRG.. GBGB.. */
pub static V4L2_PIX_FMT_SRGGB8: c_ulong = 0x42474752;
//#define V4L2_PIX_FMT_SBGGR10 v4l2_fourcc('B', 'G', '1', '0') /* 10 BGBG.. GRGR.. */
pub static V4L2_PIX_FMT_SBGGR10: c_ulong = 0x30314742;
//#define V4L2_PIX_FMT_SGBRG10 v4l2_fourcc('G', 'B', '1', '0') /* 10 GBGB.. RGRG.. */
pub static V4L2_PIX_FMT_SGBRG10: c_ulong = 0x30314247;
//#define V4L2_PIX_FMT_SGRBG10 v4l2_fourcc('B', 'A', '1', '0') /* 10 GRGR.. BGBG.. */
pub static V4L2_PIX_FMT_SGRBG10: c_ulong = 0x30314142;
//#define V4L2_PIX_FMT_SRGGB10 v4l2_fourcc('R', 'G', '1', '0') /* 10 RGRG.. GBGB.. */
pub static V4L2_PIX_FMT_SRGGB10: c_ulong = 0x30314752;
//#define V4L2_PIX_FMT_SBGGR12 v4l2_fourcc('B', 'G', '1', '2') /* 12 BGBG.. GRGR.. */
pub static V4L2_PIX_FMT_SBGGR12: c_ulong = 0x32314742;
//#define V4L2_PIX_FMT_SGBRG12 v4l2_fourcc('G', 'B', '1', '2') /* 12 GBGB.. RGRG.. */
pub static V4L2_PIX_FMT_SGBRG12: c_ulong = 0x32314247;
//#define V4L2_PIX_FMT_SGRBG12 v4l2_fourcc('B', 'A', '1', '2') /* 12 GRGR.. BGBG.. */
pub static V4L2_PIX_FMT_SGRBG12: c_ulong = 0x32314142;
//#define V4L2_PIX_FMT_SRGGB12 v4l2_fourcc('R', 'G', '1', '2') /* 12 RGRG.. GBGB.. */
pub static V4L2_PIX_FMT_SRGGB12: c_ulong = 0x32314752;
//#define V4L2_PIX_FMT_SBGGR10DPCM8 v4l2_fourcc('b', 'B', 'A', '8')
pub static V4L2_PIX_FMT_SBGGR10DPCM8: c_ulong = 0x38414262;
//#define V4L2_PIX_FMT_SGBRG10DPCM8 v4l2_fourcc('b', 'G', 'A', '8')
pub static V4L2_PIX_FMT_SGBRG10DPCM8: c_ulong = 0x38414762;
//#define V4L2_PIX_FMT_SGRBG10DPCM8 v4l2_fourcc('B', 'D', '1', '0')
pub static V4L2_PIX_FMT_SGRBG10DPCM8: c_ulong = 0x30314442;
//#define V4L2_PIX_FMT_SRGGB10DPCM8 v4l2_fourcc('b', 'R', 'A', '8')
pub static V4L2_PIX_FMT_SRGGB10DPCM8: c_ulong = 0x38415262;
//#define V4L2_PIX_FMT_SBGGR16 v4l2_fourcc('B', 'Y', 'R', '2') /* 16 BGBG.. GRGR.. */
pub static V4L2_PIX_FMT_SBGGR16: c_ulong = 0x32525942;
//#define V4L2_PIX_FMT_MJPEG v4l2_fourcc('M', 'J', 'P', 'G') /* Motion-JPEG */
pub static V4L2_PIX_FMT_MJPEG: c_ulong = 0x47504a4d;
//#define V4L2_PIX_FMT_JPEG v4l2_fourcc('J', 'P', 'E', 'G') /* JFIF JPEG */
pub static V4L2_PIX_FMT_JPEG: c_ulong = 0x4745504a;
//#define V4L2_PIX_FMT_DV v4l2_fourcc('d', 'v', 's', 'd') /* 1394 */
pub static V4L2_PIX_FMT_DV: c_ulong = 0x64737664;
//#define V4L2_PIX_FMT_MPEG v4l2_fourcc('M', 'P', 'E', 'G') /* MPEG-1/2/4 Multiplexed */
pub static V4L2_PIX_FMT_MPEG: c_ulong = 0x4745504d;
//#define V4L2_PIX_FMT_H264 v4l2_fourcc('H', '2', '6', '4') /* H264 with start codes */
pub static V4L2_PIX_FMT_H264: c_ulong = 0x34363248;
//#define V4L2_PIX_FMT_H264_NO_SC v4l2_fourcc('A', 'V', 'C', '1') /* H264 without start codes */
pub static V4L2_PIX_FMT_H264_NO_SC: c_ulong = 0x31435641;
//#define V4L2_PIX_FMT_H264_MVC v4l2_fourcc('M', '2', '6', '4') /* H264 MVC */
pub static V4L2_PIX_FMT_H264_MVC: c_ulong = 0x3436324d;
//#define V4L2_PIX_FMT_H263 v4l2_fourcc('H', '2', '6', '3') /* H263 */
pub static V4L2_PIX_FMT_H263: c_ulong = 0x33363248;
//#define V4L2_PIX_FMT_MPEG1 v4l2_fourcc('M', 'P', 'G', '1') /* MPEG-1 ES */
pub static V4L2_PIX_FMT_MPEG1: c_ulong = 0x3147504d;
//#define V4L2_PIX_FMT_MPEG2 v4l2_fourcc('M', 'P', 'G', '2') /* MPEG-2 ES */
pub static V4L2_PIX_FMT_MPEG2: c_ulong = 0x3247504d;
//#define V4L2_PIX_FMT_MPEG4 v4l2_fourcc('M', 'P', 'G', '4') /* MPEG-4 ES */
pub static V4L2_PIX_FMT_MPEG4: c_ulong = 0x3447504d;
//#define V4L2_PIX_FMT_XVID v4l2_fourcc('X', 'V', 'I', 'D') /* Xvid */
pub static V4L2_PIX_FMT_XVID: c_ulong = 0x44495658;
//#define V4L2_PIX_FMT_VC1_ANNEX_G v4l2_fourcc('V', 'C', '1', 'G') /* SMPTE 421M Annex G compliant stream */
pub static V4L2_PIX_FMT_VC1_ANNEX_G: c_ulong = 0x47314356;
//#define V4L2_PIX_FMT_VC1_ANNEX_L v4l2_fourcc('V', 'C', '1', 'L') /* SMPTE 421M Annex L compliant stream */
pub static V4L2_PIX_FMT_VC1_ANNEX_L: c_ulong = 0x4c314356;
//#define V4L2_PIX_FMT_VP8 v4l2_fourcc('V', 'P', '8', '0') /* VP8 */
pub static V4L2_PIX_FMT_VP8: c_ulong = 0x30385056;
//#define V4L2_PIX_FMT_CPIA1 v4l2_fourcc('C', 'P', 'I', 'A') /* cpia1 YUV */
pub static V4L2_PIX_FMT_CPIA1: c_ulong = 0x41495043;
//#define V4L2_PIX_FMT_WNVA v4l2_fourcc('W', 'N', 'V', 'A') /* Winnov hw compress */
pub static V4L2_PIX_FMT_WNVA: c_ulong = 0x41564e57;
//#define V4L2_PIX_FMT_SN9C10X v4l2_fourcc('S', '9', '1', '0') /* SN9C10x compression */
pub static V4L2_PIX_FMT_SN9C10X: c_ulong = 0x30313953;
//#define V4L2_PIX_FMT_SN9C20X_I420 v4l2_fourcc('S', '9', '2', '0') /* SN9C20x YUV 4:2:0 */
pub static V4L2_PIX_FMT_SN9C20X_I420: c_ulong = 0x30323953;
//#define V4L2_PIX_FMT_PWC1 v4l2_fourcc('P', 'W', 'C', '1') /* pwc older webcam */
pub static V4L2_PIX_FMT_PWC1: c_ulong = 0x31435750;
//#define V4L2_PIX_FMT_PWC2 v4l2_fourcc('P', 'W', 'C', '2') /* pwc newer webcam */
pub static V4L2_PIX_FMT_PWC2: c_ulong = 0x32435750;
//#define V4L2_PIX_FMT_ET61X251 v4l2_fourcc('E', '6', '2', '5') /* ET61X251 compression */
pub static V4L2_PIX_FMT_ET61X251: c_ulong = 0x35323645;
//#define V4L2_PIX_FMT_SPCA501 v4l2_fourcc('S', '5', '0', '1') /* YUYV per line */
pub static V4L2_PIX_FMT_SPCA501: c_ulong = 0x31303553;
//#define V4L2_PIX_FMT_SPCA505 v4l2_fourcc('S', '5', '0', '5') /* YYUV per line */
pub static V4L2_PIX_FMT_SPCA505: c_ulong = 0x35303553;
//#define V4L2_PIX_FMT_SPCA508 v4l2_fourcc('S', '5', '0', '8') /* YUVY per line */
pub static V4L2_PIX_FMT_SPCA508: c_ulong = 0x38303553;
//#define V4L2_PIX_FMT_SPCA561 v4l2_fourcc('S', '5', '6', '1') /* compressed GBRG bayer */
pub static V4L2_PIX_FMT_SPCA561: c_ulong = 0x31363553;
//#define V4L2_PIX_FMT_PAC207 v4l2_fourcc('P', '2', '0', '7') /* compressed BGGR bayer */
pub static V4L2_PIX_FMT_PAC207: c_ulong = 0x37303250;
//#define V4L2_PIX_FMT_MR97310A v4l2_fourcc('M', '3', '1', '0') /* compressed BGGR bayer */
pub static V4L2_PIX_FMT_MR97310A: c_ulong = 0x3031334d;
//#define V4L2_PIX_FMT_JL2005BCD v4l2_fourcc('J', 'L', '2', '0') /* compressed RGGB bayer */
pub static V4L2_PIX_FMT_JL2005BCD: c_ulong = 0x30324c4a;
//#define V4L2_PIX_FMT_SN9C2028 v4l2_fourcc('S', 'O', 'N', 'X') /* compressed GBRG bayer */
pub static V4L2_PIX_FMT_SN9C2028: c_ulong = 0x584e4f53;
//#define V4L2_PIX_FMT_SQ905C v4l2_fourcc('9', '0', '5', 'C') /* compressed RGGB bayer */
pub static V4L2_PIX_FMT_SQ905C: c_ulong = 0x43353039;
//#define V4L2_PIX_FMT_PJPG v4l2_fourcc('P', 'J', 'P', 'G') /* Pixart 73xx JPEG */
pub static V4L2_PIX_FMT_PJPG: c_ulong = 0x47504a50;
//#define V4L2_PIX_FMT_OV511 v4l2_fourcc('O', '5', '1', '1') /* ov511 JPEG */
pub static V4L2_PIX_FMT_OV511: c_ulong = 0x3131354f;
//#define V4L2_PIX_FMT_OV518 v4l2_fourcc('O', '5', '1', '8') /* ov518 JPEG */
pub static V4L2_PIX_FMT_OV518: c_ulong = 0x3831354f;
//#define V4L2_PIX_FMT_STV0680 v4l2_fourcc('S', '6', '8', '0') /* stv0680 bayer */
pub static V4L2_PIX_FMT_STV0680: c_ulong = 0x30383653;
//#define V4L2_PIX_FMT_TM6000 v4l2_fourcc('T', 'M', '6', '0') /* tm5600/tm60x0 */
pub static V4L2_PIX_FMT_TM6000: c_ulong = 0x30364d54;
//#define V4L2_PIX_FMT_CIT_YYVYUY v4l2_fourcc('C', 'I', 'T', 'V') /* one line of Y then 1 line of VYUY */
pub static V4L2_PIX_FMT_CIT_YYVYUY: c_ulong = 0x56544943;
//#define V4L2_PIX_FMT_KONICA420 v4l2_fourcc('K', 'O', 'N', 'I') /* YUV420 planar in blocks of 256 pixels */
pub static V4L2_PIX_FMT_KONICA420: c_ulong = 0x494e4f4b;
//#define V4L2_PIX_FMT_JPGL v4l2_fourcc('J', 'P', 'G', 'L') /* JPEG-Lite */
pub static V4L2_PIX_FMT_JPGL: c_ulong = 0x4c47504a;
//#define V4L2_PIX_FMT_SE401 v4l2_fourcc('S', '4', '0', '1') /* se401 janggu compressed rgb */
pub static V4L2_PIX_FMT_SE401: c_ulong = 0x31303453;
//#define V4L2_PIX_FMT_S5C_UYVY_JPG v4l2_fourcc('S', '5', 'C', 'I') /* S5C73M3 interleaved UYVY/JPEG */
pub static V4L2_PIX_FMT_S5C_UYVY_JPG: c_ulong = 0x49433553;
//#define V4L2_FMT_FLAG_COMPRESSED 0x0001
pub static V4L2_FMT_FLAG_COMPRESSED: c_ulong = 0x1;
//#define V4L2_FMT_FLAG_EMULATED 0x0002
pub static V4L2_FMT_FLAG_EMULATED: c_ulong = 0x2;
//#define V4L2_TC_TYPE_24FPS 1
pub static V4L2_TC_TYPE_24FPS: c_ulong = 0x1;
//#define V4L2_TC_TYPE_25FPS 2
pub static V4L2_TC_TYPE_25FPS: c_ulong = 0x2;
//#define V4L2_TC_TYPE_30FPS 3
pub static V4L2_TC_TYPE_30FPS: c_ulong = 0x3;
//#define V4L2_TC_TYPE_50FPS 4
pub static V4L2_TC_TYPE_50FPS: c_ulong = 0x4;
//#define V4L2_TC_TYPE_60FPS 5
pub static V4L2_TC_TYPE_60FPS: c_ulong = 0x5;
//#define V4L2_TC_FLAG_DROPFRAME 0x0001 /* "drop-frame" mode */
pub static V4L2_TC_FLAG_DROPFRAME: c_ulong = 0x1;
//#define V4L2_TC_FLAG_COLORFRAME 0x0002
pub static V4L2_TC_FLAG_COLORFRAME: c_ulong = 0x2;
//#define V4L2_TC_USERBITS_field 0x000C
pub static V4L2_TC_USERBITS_field: c_ulong = 0xc;
//#define V4L2_TC_USERBITS_USERDEFINED 0x0000
pub static V4L2_TC_USERBITS_USERDEFINED: c_ulong = 0x0;
//#define V4L2_TC_USERBITS_8BITCHARS 0x0008
pub static V4L2_TC_USERBITS_8BITCHARS: c_ulong = 0x8;
//#define V4L2_JPEG_MARKER_DHT (1<<3) /* Define Huffman Tables */
pub static V4L2_JPEG_MARKER_DHT: c_ulong = 0x8;
//#define V4L2_JPEG_MARKER_DQT (1<<4) /* Define Quantization Tables */
pub static V4L2_JPEG_MARKER_DQT: c_ulong = 0x10;
//#define V4L2_JPEG_MARKER_DRI (1<<5) /* Define Restart Interval */
pub static V4L2_JPEG_MARKER_DRI: c_ulong = 0x20;
//#define V4L2_JPEG_MARKER_COM (1<<6) /* Comment segment */
pub static V4L2_JPEG_MARKER_COM: c_ulong = 0x40;
//#define V4L2_JPEG_MARKER_APP (1<<7) /* App segment, driver will
pub static V4L2_JPEG_MARKER_APP: c_ulong = 0x80;
//#define V4L2_BUF_FLAG_MAPPED 0x0001 /* Buffer is mapped (flag) */
pub static V4L2_BUF_FLAG_MAPPED: c_ulong = 0x1;
//#define V4L2_BUF_FLAG_QUEUED 0x0002 /* Buffer is queued for processing */
pub static V4L2_BUF_FLAG_QUEUED: c_ulong = 0x2;
//#define V4L2_BUF_FLAG_DONE 0x0004 /* Buffer is ready */
pub static V4L2_BUF_FLAG_DONE: c_ulong = 0x4;
//#define V4L2_BUF_FLAG_KEYFRAME 0x0008 /* Image is a keyframe (I-frame) */
pub static V4L2_BUF_FLAG_KEYFRAME: c_ulong = 0x8;
//#define V4L2_BUF_FLAG_PFRAME 0x0010 /* Image is a P-frame */
pub static V4L2_BUF_FLAG_PFRAME: c_ulong = 0x10;
//#define V4L2_BUF_FLAG_BFRAME 0x0020 /* Image is a B-frame */
pub static V4L2_BUF_FLAG_BFRAME: c_ulong = 0x20;
//#define V4L2_BUF_FLAG_ERROR 0x0040
pub static V4L2_BUF_FLAG_ERROR: c_ulong = 0x40;
//#define V4L2_BUF_FLAG_TIMECODE 0x0100 /* timecode field is valid */
pub static V4L2_BUF_FLAG_TIMECODE: c_ulong = 0x100;
//#define V4L2_BUF_FLAG_PREPARED 0x0400 /* Buffer is prepared for queuing */
pub static V4L2_BUF_FLAG_PREPARED: c_ulong = 0x400;
//#define V4L2_BUF_FLAG_NO_CACHE_INVALIDATE 0x0800
pub static V4L2_BUF_FLAG_NO_CACHE_INVALIDATE: c_ulong = 0x800;
//#define V4L2_BUF_FLAG_NO_CACHE_CLEAN 0x1000
pub static V4L2_BUF_FLAG_NO_CACHE_CLEAN: c_ulong = 0x1000;
//#define V4L2_FBUF_CAP_EXTERNOVERLAY 0x0001
pub static V4L2_FBUF_CAP_EXTERNOVERLAY: c_ulong = 0x1;
//#define V4L2_FBUF_CAP_CHROMAKEY 0x0002
pub static V4L2_FBUF_CAP_CHROMAKEY: c_ulong = 0x2;
//#define V4L2_FBUF_CAP_LIST_CLIPPING 0x0004
pub static V4L2_FBUF_CAP_LIST_CLIPPING: c_ulong = 0x4;
//#define V4L2_FBUF_CAP_BITMAP_CLIPPING 0x0008
pub static V4L2_FBUF_CAP_BITMAP_CLIPPING: c_ulong = 0x8;
//#define V4L2_FBUF_CAP_LOCAL_ALPHA 0x0010
pub static V4L2_FBUF_CAP_LOCAL_ALPHA: c_ulong = 0x10;
//#define V4L2_FBUF_CAP_GLOBAL_ALPHA 0x0020
pub static V4L2_FBUF_CAP_GLOBAL_ALPHA: c_ulong = 0x20;
//#define V4L2_FBUF_CAP_LOCAL_INV_ALPHA 0x0040
pub static V4L2_FBUF_CAP_LOCAL_INV_ALPHA: c_ulong = 0x40;
//#define V4L2_FBUF_CAP_SRC_CHROMAKEY 0x0080
pub static V4L2_FBUF_CAP_SRC_CHROMAKEY: c_ulong = 0x80;
//#define V4L2_FBUF_FLAG_PRIMARY 0x0001
pub static V4L2_FBUF_FLAG_PRIMARY: c_ulong = 0x1;
//#define V4L2_FBUF_FLAG_OVERLAY 0x0002
pub static V4L2_FBUF_FLAG_OVERLAY: c_ulong = 0x2;
//#define V4L2_FBUF_FLAG_CHROMAKEY 0x0004
pub static V4L2_FBUF_FLAG_CHROMAKEY: c_ulong = 0x4;
//#define V4L2_FBUF_FLAG_LOCAL_ALPHA 0x0008
pub static V4L2_FBUF_FLAG_LOCAL_ALPHA: c_ulong = 0x8;
//#define V4L2_FBUF_FLAG_GLOBAL_ALPHA 0x0010
pub static V4L2_FBUF_FLAG_GLOBAL_ALPHA: c_ulong = 0x10;
//#define V4L2_FBUF_FLAG_LOCAL_INV_ALPHA 0x0020
pub static V4L2_FBUF_FLAG_LOCAL_INV_ALPHA: c_ulong = 0x20;
//#define V4L2_FBUF_FLAG_SRC_CHROMAKEY 0x0040
pub static V4L2_FBUF_FLAG_SRC_CHROMAKEY: c_ulong = 0x40;
//#define V4L2_MODE_HIGHQUALITY 0x0001 /* High quality imaging mode */
pub static V4L2_MODE_HIGHQUALITY: c_ulong = 0x1;
//#define V4L2_CAP_TIMEPERFRAME 0x1000 /* timeperframe field is supported */
pub static V4L2_CAP_TIMEPERFRAME: c_ulong = 0x1000;
//#define V4L2_STD_PAL_B ((v4l2_std_id)0x00000001)
pub static V4L2_STD_PAL_B: c_ulong = 0x1;
//#define V4L2_STD_PAL_B1 ((v4l2_std_id)0x00000002)
pub static V4L2_STD_PAL_B1: c_ulong = 0x2;
//#define V4L2_STD_PAL_G ((v4l2_std_id)0x00000004)
pub static V4L2_STD_PAL_G: c_ulong = 0x4;
//#define V4L2_STD_PAL_H ((v4l2_std_id)0x00000008)
pub static V4L2_STD_PAL_H: c_ulong = 0x8;
//#define V4L2_STD_PAL_I ((v4l2_std_id)0x00000010)
pub static V4L2_STD_PAL_I: c_ulong = 0x10;
//#define V4L2_STD_PAL_D ((v4l2_std_id)0x00000020)
pub static V4L2_STD_PAL_D: c_ulong = 0x20;
//#define V4L2_STD_PAL_D1 ((v4l2_std_id)0x00000040)
pub static V4L2_STD_PAL_D1: c_ulong = 0x40;
//#define V4L2_STD_PAL_K ((v4l2_std_id)0x00000080)
pub static V4L2_STD_PAL_K: c_ulong = 0x80;
//#define V4L2_STD_PAL_M ((v4l2_std_id)0x00000100)
pub static V4L2_STD_PAL_M: c_ulong = 0x100;
//#define V4L2_STD_PAL_N ((v4l2_std_id)0x00000200)
pub static V4L2_STD_PAL_N: c_ulong = 0x200;
//#define V4L2_STD_PAL_Nc ((v4l2_std_id)0x00000400)
pub static V4L2_STD_PAL_Nc: c_ulong = 0x400;
//#define V4L2_STD_PAL_60 ((v4l2_std_id)0x00000800)
pub static V4L2_STD_PAL_60: c_ulong = 0x800;
//#define V4L2_STD_NTSC_M ((v4l2_std_id)0x00001000) /* BTSC */
pub static V4L2_STD_NTSC_M: c_ulong = 0x1000;
//#define V4L2_STD_NTSC_M_JP ((v4l2_std_id)0x00002000) /* EIA-J */
pub static V4L2_STD_NTSC_M_JP: c_ulong = 0x2000;
//#define V4L2_STD_NTSC_443 ((v4l2_std_id)0x00004000)
pub static V4L2_STD_NTSC_443: c_ulong = 0x4000;
//#define V4L2_STD_NTSC_M_KR ((v4l2_std_id)0x00008000) /* FM A2 */
pub static V4L2_STD_NTSC_M_KR: c_ulong = 0x8000;
//#define V4L2_STD_SECAM_B ((v4l2_std_id)0x00010000)
pub static V4L2_STD_SECAM_B: c_ulong = 0x10000;
//#define V4L2_STD_SECAM_D ((v4l2_std_id)0x00020000)
pub static V4L2_STD_SECAM_D: c_ulong = 0x20000;
//#define V4L2_STD_SECAM_G ((v4l2_std_id)0x00040000)
pub static V4L2_STD_SECAM_G: c_ulong = 0x40000;
//#define V4L2_STD_SECAM_H ((v4l2_std_id)0x00080000)
pub static V4L2_STD_SECAM_H: c_ulong = 0x80000;
//#define V4L2_STD_SECAM_K ((v4l2_std_id)0x00100000)
pub static V4L2_STD_SECAM_K: c_ulong = 0x100000;
//#define V4L2_STD_SECAM_K1 ((v4l2_std_id)0x00200000)
pub static V4L2_STD_SECAM_K1: c_ulong = 0x200000;
//#define V4L2_STD_SECAM_L ((v4l2_std_id)0x00400000)
pub static V4L2_STD_SECAM_L: c_ulong = 0x400000;
//#define V4L2_STD_SECAM_LC ((v4l2_std_id)0x00800000)
pub static V4L2_STD_SECAM_LC: c_ulong = 0x800000;
//#define V4L2_STD_ATSC_8_VSB ((v4l2_std_id)0x01000000)
pub static V4L2_STD_ATSC_8_VSB: c_ulong = 0x1000000;
//#define V4L2_STD_ATSC_16_VSB ((v4l2_std_id)0x02000000)
pub static V4L2_STD_ATSC_16_VSB: c_ulong = 0x2000000;
//#define V4L2_STD_NTSC (V4L2_STD_NTSC_M | ...
pub static V4L2_STD_NTSC: c_ulong = 0xb000;
//#define V4L2_STD_SECAM_DK (V4L2_STD_SECAM_D | ...
pub static V4L2_STD_SECAM_DK: c_ulong = 0x320000;
//#define V4L2_STD_SECAM (V4L2_STD_SECAM_B | ...
pub static V4L2_STD_SECAM: c_ulong = 0xff0000;
//#define V4L2_STD_PAL_BG (V4L2_STD_PAL_B | ...
pub static V4L2_STD_PAL_BG: c_ulong = 0x7;
//#define V4L2_STD_PAL_DK (V4L2_STD_PAL_D | ...
pub static V4L2_STD_PAL_DK: c_ulong = 0xe0;
//#define V4L2_STD_PAL (V4L2_STD_PAL_BG | ...
pub static V4L2_STD_PAL: c_ulong = 0xff;
//#define V4L2_STD_B (V4L2_STD_PAL_B | ...
pub static V4L2_STD_B: c_ulong = 0x10003;
//#define V4L2_STD_G (V4L2_STD_PAL_G | ...
pub static V4L2_STD_G: c_ulong = 0x40004;
//#define V4L2_STD_H (V4L2_STD_PAL_H | ...
pub static V4L2_STD_H: c_ulong = 0x80008;
//#define V4L2_STD_L (V4L2_STD_SECAM_L | ...
pub static V4L2_STD_L: c_ulong = 0xc00000;
//#define V4L2_STD_GH (V4L2_STD_G | ...
pub static V4L2_STD_GH: c_ulong = 0xc000c;
//#define V4L2_STD_DK (V4L2_STD_PAL_DK | ...
pub static V4L2_STD_DK: c_ulong = 0x3200e0;
//#define V4L2_STD_BG (V4L2_STD_B | ...
pub static V4L2_STD_BG: c_ulong = 0x50007;
//#define V4L2_STD_MN (V4L2_STD_PAL_M | ...
pub static V4L2_STD_MN: c_ulong = 0xb700;
//#define V4L2_STD_MTS (V4L2_STD_NTSC_M | ...
pub static V4L2_STD_MTS: c_ulong = 0x1700;
//#define V4L2_STD_525_60 (V4L2_STD_PAL_M | ...
pub static V4L2_STD_525_60: c_ulong = 0xf900;
//#define V4L2_STD_625_50 (V4L2_STD_PAL | ...
pub static V4L2_STD_625_50: c_ulong = 0xff06ff;
//#define V4L2_STD_ATSC (V4L2_STD_ATSC_8_VSB | ...
pub static V4L2_STD_ATSC: c_ulong = 0x3000000;
//#define V4L2_STD_UNKNOWN 0
pub static V4L2_STD_UNKNOWN: c_ulong = 0x0;
//#define V4L2_STD_ALL (V4L2_STD_525_60 | ...
pub static V4L2_STD_ALL: c_ulong = 0xffffff;
//#define V4L2_DV_INVALID 0
pub static V4L2_DV_INVALID: c_ulong = 0x0;
//#define V4L2_DV_480P59_94 1 /* BT.1362 */
pub static V4L2_DV_480P59_94: c_ulong = 0x1;
//#define V4L2_DV_576P50 2 /* BT.1362 */
pub static V4L2_DV_576P50: c_ulong = 0x2;
//#define V4L2_DV_720P24 3 /* SMPTE 296M */
pub static V4L2_DV_720P24: c_ulong = 0x3;
//#define V4L2_DV_720P25 4 /* SMPTE 296M */
pub static V4L2_DV_720P25: c_ulong = 0x4;
//#define V4L2_DV_720P30 5 /* SMPTE 296M */
pub static V4L2_DV_720P30: c_ulong = 0x5;
//#define V4L2_DV_720P50 6 /* SMPTE 296M */
pub static V4L2_DV_720P50: c_ulong = 0x6;
//#define V4L2_DV_720P59_94 7 /* SMPTE 274M */
pub static V4L2_DV_720P59_94: c_ulong = 0x7;
//#define V4L2_DV_720P60 8 /* SMPTE 274M/296M */
pub static V4L2_DV_720P60: c_ulong = 0x8;
//#define V4L2_DV_1080I29_97 9 /* BT.1120/ SMPTE 274M */
pub static V4L2_DV_1080I29_97: c_ulong = 0x9;
//#define V4L2_DV_1080I30 10 /* BT.1120/ SMPTE 274M */
pub static V4L2_DV_1080I30: c_ulong = 0xa;
//#define V4L2_DV_1080I25 11 /* BT.1120 */
pub static V4L2_DV_1080I25: c_ulong = 0xb;
//#define V4L2_DV_1080I50 12 /* SMPTE 296M */
pub static V4L2_DV_1080I50: c_ulong = 0xc;
//#define V4L2_DV_1080I60 13 /* SMPTE 296M */
pub static V4L2_DV_1080I60: c_ulong = 0xd;
//#define V4L2_DV_1080P24 14 /* SMPTE 296M */
pub static V4L2_DV_1080P24: c_ulong = 0xe;
//#define V4L2_DV_1080P25 15 /* SMPTE 296M */
pub static V4L2_DV_1080P25: c_ulong = 0xf;
//#define V4L2_DV_1080P30 16 /* SMPTE 296M */
pub static V4L2_DV_1080P30: c_ulong = 0x10;
//#define V4L2_DV_1080P50 17 /* BT.1120 */
pub static V4L2_DV_1080P50: c_ulong = 0x11;
//#define V4L2_DV_1080P60 18 /* BT.1120 */
pub static V4L2_DV_1080P60: c_ulong = 0x12;
//#define V4L2_DV_PROGRESSIVE 0
pub static V4L2_DV_PROGRESSIVE: c_ulong = 0x0;
//#define V4L2_DV_INTERLACED 1
pub static V4L2_DV_INTERLACED: c_ulong = 0x1;
//#define V4L2_DV_VSYNC_POS_POL 0x00000001
pub static V4L2_DV_VSYNC_POS_POL: c_ulong = 0x1;
//#define V4L2_DV_HSYNC_POS_POL 0x00000002
pub static V4L2_DV_HSYNC_POS_POL: c_ulong = 0x2;
//#define V4L2_DV_BT_STD_CEA861 (1 << 0) /* CEA-861 Digital TV Profile */
pub static V4L2_DV_BT_STD_CEA861: c_ulong = 0x1;
//#define V4L2_DV_BT_STD_DMT (1 << 1) /* VESA Discrete Monitor Timings */
pub static V4L2_DV_BT_STD_DMT: c_ulong = 0x2;
//#define V4L2_DV_BT_STD_CVT (1 << 2) /* VESA Coordinated Video Timings */
pub static V4L2_DV_BT_STD_CVT: c_ulong = 0x4;
//#define V4L2_DV_BT_STD_GTF (1 << 3) /* VESA Generalized Timings Formula */
pub static V4L2_DV_BT_STD_GTF: c_ulong = 0x8;
//#define V4L2_DV_FL_REDUCED_BLANKING (1 << 0)
pub static V4L2_DV_FL_REDUCED_BLANKING: c_ulong = 0x1;
//#define V4L2_DV_FL_CAN_REDUCE_FPS (1 << 1)
pub static V4L2_DV_FL_CAN_REDUCE_FPS: c_ulong = 0x2;
//#define V4L2_DV_FL_REDUCED_FPS (1 << 2)
pub static V4L2_DV_FL_REDUCED_FPS: c_ulong = 0x4;
//#define V4L2_DV_FL_HALF_LINE (1 << 0)
pub static V4L2_DV_FL_HALF_LINE: c_ulong = 0x1;
//#define V4L2_DV_BT_656_1120 0 /* BT.656/1120 timing type */
pub static V4L2_DV_BT_656_1120: c_ulong = 0x0;
//#define V4L2_DV_BT_CAP_INTERLACED (1 << 0)
pub static V4L2_DV_BT_CAP_INTERLACED: c_ulong = 0x1;
//#define V4L2_DV_BT_CAP_PROGRESSIVE (1 << 1)
pub static V4L2_DV_BT_CAP_PROGRESSIVE: c_ulong = 0x2;
//#define V4L2_DV_BT_CAP_REDUCED_BLANKING (1 << 2)
pub static V4L2_DV_BT_CAP_REDUCED_BLANKING: c_ulong = 0x4;
//#define V4L2_DV_BT_CAP_CUSTOM (1 << 3)
pub static V4L2_DV_BT_CAP_CUSTOM: c_ulong = 0x8;
//#define V4L2_INPUT_TYPE_TUNER 1
pub static V4L2_INPUT_TYPE_TUNER: c_ulong = 0x1;
//#define V4L2_INPUT_TYPE_CAMERA 2
pub static V4L2_INPUT_TYPE_CAMERA: c_ulong = 0x2;
//#define V4L2_IN_ST_NO_POWER 0x00000001 /* Attached device is off */
pub static V4L2_IN_ST_NO_POWER: c_ulong = 0x1;
//#define V4L2_IN_ST_NO_SIGNAL 0x00000002
pub static V4L2_IN_ST_NO_SIGNAL: c_ulong = 0x2;
//#define V4L2_IN_ST_NO_COLOR 0x00000004
pub static V4L2_IN_ST_NO_COLOR: c_ulong = 0x4;
//#define V4L2_IN_ST_HFLIP 0x00000010 /* Frames are flipped horizontally */
pub static V4L2_IN_ST_HFLIP: c_ulong = 0x10;
//#define V4L2_IN_ST_VFLIP 0x00000020 /* Frames are flipped vertically */
pub static V4L2_IN_ST_VFLIP: c_ulong = 0x20;
//#define V4L2_IN_ST_NO_H_LOCK 0x00000100 /* No horizontal sync lock */
pub static V4L2_IN_ST_NO_H_LOCK: c_ulong = 0x100;
//#define V4L2_IN_ST_COLOR_KILL 0x00000200 /* Color killer is active */
pub static V4L2_IN_ST_COLOR_KILL: c_ulong = 0x200;
//#define V4L2_IN_ST_NO_SYNC 0x00010000 /* No synchronization lock */
pub static V4L2_IN_ST_NO_SYNC: c_ulong = 0x10000;
//#define V4L2_IN_ST_NO_EQU 0x00020000 /* No equalizer lock */
pub static V4L2_IN_ST_NO_EQU: c_ulong = 0x20000;
//#define V4L2_IN_ST_NO_CARRIER 0x00040000 /* Carrier recovery failed */
pub static V4L2_IN_ST_NO_CARRIER: c_ulong = 0x40000;
//#define V4L2_IN_ST_MACROVISION 0x01000000 /* Macrovision detected */
pub static V4L2_IN_ST_MACROVISION: c_ulong = 0x1000000;
//#define V4L2_IN_ST_NO_ACCESS 0x02000000 /* Conditional access denied */
pub static V4L2_IN_ST_NO_ACCESS: c_ulong = 0x2000000;
//#define V4L2_IN_ST_VTR 0x04000000 /* VTR time constant */
pub static V4L2_IN_ST_VTR: c_ulong = 0x4000000;
//#define V4L2_IN_CAP_PRESETS 0x00000001 /* Supports S_DV_PRESET */
pub static V4L2_IN_CAP_PRESETS: c_ulong = 0x1;
//#define V4L2_IN_CAP_DV_TIMINGS 0x00000002 /* Supports S_DV_TIMINGS */
pub static V4L2_IN_CAP_DV_TIMINGS: c_ulong = 0x2;
//#define V4L2_IN_CAP_CUSTOM_TIMINGS V4L2_IN_CAP_DV_TIMINGS /* For compatibility */
pub static V4L2_IN_CAP_CUSTOM_TIMINGS: c_ulong = 0x2;
//#define V4L2_IN_CAP_STD 0x00000004 /* Supports S_STD */
pub static V4L2_IN_CAP_STD: c_ulong = 0x4;
//#define V4L2_OUTPUT_TYPE_MODULATOR 1
pub static V4L2_OUTPUT_TYPE_MODULATOR: c_ulong = 0x1;
//#define V4L2_OUTPUT_TYPE_ANALOG 2
pub static V4L2_OUTPUT_TYPE_ANALOG: c_ulong = 0x2;
//#define V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY 3
pub static V4L2_OUTPUT_TYPE_ANALOGVGAOVERLAY: c_ulong = 0x3;
//#define V4L2_OUT_CAP_PRESETS 0x00000001 /* Supports S_DV_PRESET */
pub static V4L2_OUT_CAP_PRESETS: c_ulong = 0x1;
//#define V4L2_OUT_CAP_DV_TIMINGS 0x00000002 /* Supports S_DV_TIMINGS */
pub static V4L2_OUT_CAP_DV_TIMINGS: c_ulong = 0x2;
//#define V4L2_OUT_CAP_CUSTOM_TIMINGS V4L2_OUT_CAP_DV_TIMINGS /* For compatibility */
pub static V4L2_OUT_CAP_CUSTOM_TIMINGS: c_ulong = 0x2;
//#define V4L2_OUT_CAP_STD 0x00000004 /* Supports S_STD */
pub static V4L2_OUT_CAP_STD: c_ulong = 0x4;
//#define V4L2_CTRL_ID_MASK (0x0fffffff)
pub static V4L2_CTRL_ID_MASK: c_ulong = 0xfffffff;
//#define V4L2_CTRL_FLAG_DISABLED 0x0001
pub static V4L2_CTRL_FLAG_DISABLED: c_ulong = 0x1;
//#define V4L2_CTRL_FLAG_GRABBED 0x0002
pub static V4L2_CTRL_FLAG_GRABBED: c_ulong = 0x2;
//#define V4L2_CTRL_FLAG_READ_ONLY 0x0004
pub static V4L2_CTRL_FLAG_READ_ONLY: c_ulong = 0x4;
//#define V4L2_CTRL_FLAG_UPDATE 0x0008
pub static V4L2_CTRL_FLAG_UPDATE: c_ulong = 0x8;
//#define V4L2_CTRL_FLAG_INACTIVE 0x0010
pub static V4L2_CTRL_FLAG_INACTIVE: c_ulong = 0x10;
//#define V4L2_CTRL_FLAG_SLIDER 0x0020
pub static V4L2_CTRL_FLAG_SLIDER: c_ulong = 0x20;
//#define V4L2_CTRL_FLAG_WRITE_ONLY 0x0040
pub static V4L2_CTRL_FLAG_WRITE_ONLY: c_ulong = 0x40;
//#define V4L2_CTRL_FLAG_VOLATILE 0x0080
pub static V4L2_CTRL_FLAG_VOLATILE: c_ulong = 0x80;
//#define V4L2_CTRL_FLAG_NEXT_CTRL 0x80000000
pub static V4L2_CTRL_FLAG_NEXT_CTRL: c_ulong = 0x80000000;
//#define V4L2_CID_MAX_CTRLS 1024
pub static V4L2_CID_MAX_CTRLS: c_ulong = 0x400;
//#define V4L2_CID_PRIVATE_BASE 0x08000000
pub static V4L2_CID_PRIVATE_BASE: c_ulong = 0x8000000;
//#define V4L2_CID_DV_CLASS_BASE (V4L2_CTRL_CLASS_DV | 0x900)
pub static V4L2_CID_DV_CLASS_BASE: c_ulong = 0xa00900;
//#define V4L2_CID_DV_CLASS (V4L2_CTRL_CLASS_DV | 1)
pub static V4L2_CID_DV_CLASS: c_ulong = 0xa00001;
//#define V4L2_CID_DV_TX_HOTPLUG (V4L2_CID_DV_CLASS_BASE + 1)
pub static V4L2_CID_DV_TX_HOTPLUG: c_ulong = 0xa00901;
//#define V4L2_CID_DV_TX_RXSENSE (V4L2_CID_DV_CLASS_BASE + 2)
pub static V4L2_CID_DV_TX_RXSENSE: c_ulong = 0xa00902;
//#define V4L2_CID_DV_TX_EDID_PRESENT (V4L2_CID_DV_CLASS_BASE + 3)
pub static V4L2_CID_DV_TX_EDID_PRESENT: c_ulong = 0xa00903;
//#define V4L2_CID_DV_TX_MODE (V4L2_CID_DV_CLASS_BASE + 4)
pub static V4L2_CID_DV_TX_MODE: c_ulong = 0xa00904;
//#define V4L2_CID_DV_TX_RGB_RANGE (V4L2_CID_DV_CLASS_BASE + 5)
pub static V4L2_CID_DV_TX_RGB_RANGE: c_ulong = 0xa00905;
//#define V4L2_CID_DV_RX_POWER_PRESENT (V4L2_CID_DV_CLASS_BASE + 100)
pub static V4L2_CID_DV_RX_POWER_PRESENT: c_ulong = 0xa00964;
//#define V4L2_CID_DV_RX_RGB_RANGE (V4L2_CID_DV_CLASS_BASE + 101)
pub static V4L2_CID_DV_RX_RGB_RANGE: c_ulong = 0xa00965;
//#define V4L2_TUNER_CAP_LOW 0x0001
pub static V4L2_TUNER_CAP_LOW: c_ulong = 0x1;
//#define V4L2_TUNER_CAP_NORM 0x0002
pub static V4L2_TUNER_CAP_NORM: c_ulong = 0x2;
//#define V4L2_TUNER_CAP_HWSEEK_BOUNDED 0x0004
pub static V4L2_TUNER_CAP_HWSEEK_BOUNDED: c_ulong = 0x4;
//#define V4L2_TUNER_CAP_HWSEEK_WRAP 0x0008
pub static V4L2_TUNER_CAP_HWSEEK_WRAP: c_ulong = 0x8;
//#define V4L2_TUNER_CAP_STEREO 0x0010
pub static V4L2_TUNER_CAP_STEREO: c_ulong = 0x10;
//#define V4L2_TUNER_CAP_LANG2 0x0020
pub static V4L2_TUNER_CAP_LANG2: c_ulong = 0x20;
//#define V4L2_TUNER_CAP_SAP 0x0020
pub static V4L2_TUNER_CAP_SAP: c_ulong = 0x20;
//#define V4L2_TUNER_CAP_LANG1 0x0040
pub static V4L2_TUNER_CAP_LANG1: c_ulong = 0x40;
//#define V4L2_TUNER_CAP_RDS 0x0080
pub static V4L2_TUNER_CAP_RDS: c_ulong = 0x80;
//#define V4L2_TUNER_CAP_RDS_BLOCK_IO 0x0100
pub static V4L2_TUNER_CAP_RDS_BLOCK_IO: c_ulong = 0x100;
//#define V4L2_TUNER_CAP_RDS_CONTROLS 0x0200
pub static V4L2_TUNER_CAP_RDS_CONTROLS: c_ulong = 0x200;
//#define V4L2_TUNER_CAP_FREQ_BANDS 0x0400
pub static V4L2_TUNER_CAP_FREQ_BANDS: c_ulong = 0x400;
//#define V4L2_TUNER_CAP_HWSEEK_PROG_LIM 0x0800
pub static V4L2_TUNER_CAP_HWSEEK_PROG_LIM: c_ulong = 0x800;
//#define V4L2_TUNER_SUB_MONO 0x0001
pub static V4L2_TUNER_SUB_MONO: c_ulong = 0x1;
//#define V4L2_TUNER_SUB_STEREO 0x0002
pub static V4L2_TUNER_SUB_STEREO: c_ulong = 0x2;
//#define V4L2_TUNER_SUB_LANG2 0x0004
pub static V4L2_TUNER_SUB_LANG2: c_ulong = 0x4;
//#define V4L2_TUNER_SUB_SAP 0x0004
pub static V4L2_TUNER_SUB_SAP: c_ulong = 0x4;
//#define V4L2_TUNER_SUB_LANG1 0x0008
pub static V4L2_TUNER_SUB_LANG1: c_ulong = 0x8;
//#define V4L2_TUNER_SUB_RDS 0x0010
pub static V4L2_TUNER_SUB_RDS: c_ulong = 0x10;
//#define V4L2_TUNER_MODE_MONO 0x0000
pub static V4L2_TUNER_MODE_MONO: c_ulong = 0x0;
//#define V4L2_TUNER_MODE_STEREO 0x0001
pub static V4L2_TUNER_MODE_STEREO: c_ulong = 0x1;
//#define V4L2_TUNER_MODE_LANG2 0x0002
pub static V4L2_TUNER_MODE_LANG2: c_ulong = 0x2;
//#define V4L2_TUNER_MODE_SAP 0x0002
pub static V4L2_TUNER_MODE_SAP: c_ulong = 0x2;
//#define V4L2_TUNER_MODE_LANG1 0x0003
pub static V4L2_TUNER_MODE_LANG1: c_ulong = 0x3;
//#define V4L2_TUNER_MODE_LANG1_LANG2 0x0004
pub static V4L2_TUNER_MODE_LANG1_LANG2: c_ulong = 0x4;
//#define V4L2_BAND_MODULATION_VSB (1 << 1)
pub static V4L2_BAND_MODULATION_VSB: c_ulong = 0x2;
//#define V4L2_BAND_MODULATION_FM (1 << 2)
pub static V4L2_BAND_MODULATION_FM: c_ulong = 0x4;
//#define V4L2_BAND_MODULATION_AM (1 << 3)
pub static V4L2_BAND_MODULATION_AM: c_ulong = 0x8;
//#define V4L2_RDS_BLOCK_MSK 0x7
pub static V4L2_RDS_BLOCK_MSK: c_ulong = 0x7;
//#define V4L2_RDS_BLOCK_A 0
pub static V4L2_RDS_BLOCK_A: c_ulong = 0x0;
//#define V4L2_RDS_BLOCK_B 1
pub static V4L2_RDS_BLOCK_B: c_ulong = 0x1;
//#define V4L2_RDS_BLOCK_C 2
pub static V4L2_RDS_BLOCK_C: c_ulong = 0x2;
//#define V4L2_RDS_BLOCK_D 3
pub static V4L2_RDS_BLOCK_D: c_ulong = 0x3;
//#define V4L2_RDS_BLOCK_C_ALT 4
pub static V4L2_RDS_BLOCK_C_ALT: c_ulong = 0x4;
//#define V4L2_RDS_BLOCK_INVALID 7
pub static V4L2_RDS_BLOCK_INVALID: c_ulong = 0x7;
//#define V4L2_RDS_BLOCK_CORRECTED 0x40
pub static V4L2_RDS_BLOCK_CORRECTED: c_ulong = 0x40;
//#define V4L2_RDS_BLOCK_ERROR 0x80
pub static V4L2_RDS_BLOCK_ERROR: c_ulong = 0x80;
//#define V4L2_AUDCAP_STEREO 0x00001
pub static V4L2_AUDCAP_STEREO: c_ulong = 0x1;
//#define V4L2_AUDCAP_AVL 0x00002
pub static V4L2_AUDCAP_AVL: c_ulong = 0x2;
//#define V4L2_AUDMODE_AVL 0x00001
pub static V4L2_AUDMODE_AVL: c_ulong = 0x1;
//#define V4L2_ENC_IDX_FRAME_I (0)
pub static V4L2_ENC_IDX_FRAME_I: c_ulong = 0x0;
//#define V4L2_ENC_IDX_FRAME_P (1)
pub static V4L2_ENC_IDX_FRAME_P: c_ulong = 0x1;
//#define V4L2_ENC_IDX_FRAME_B (2)
pub static V4L2_ENC_IDX_FRAME_B: c_ulong = 0x2;
//#define V4L2_ENC_IDX_FRAME_MASK (0xf)
pub static V4L2_ENC_IDX_FRAME_MASK: c_ulong = 0xf;
//#define V4L2_ENC_IDX_ENTRIES (64)
pub static V4L2_ENC_IDX_ENTRIES: c_ulong = 0x40;
//#define V4L2_ENC_CMD_START (0)
pub static V4L2_ENC_CMD_START: c_ulong = 0x0;
//#define V4L2_ENC_CMD_STOP (1)
pub static V4L2_ENC_CMD_STOP: c_ulong = 0x1;
//#define V4L2_ENC_CMD_PAUSE (2)
pub static V4L2_ENC_CMD_PAUSE: c_ulong = 0x2;
//#define V4L2_ENC_CMD_RESUME (3)
pub static V4L2_ENC_CMD_RESUME: c_ulong = 0x3;
//#define V4L2_ENC_CMD_STOP_AT_GOP_END (1 << 0)
pub static V4L2_ENC_CMD_STOP_AT_GOP_END: c_ulong = 0x1;
//#define V4L2_DEC_CMD_START (0)
pub static V4L2_DEC_CMD_START: c_ulong = 0x0;
//#define V4L2_DEC_CMD_STOP (1)
pub static V4L2_DEC_CMD_STOP: c_ulong = 0x1;
//#define V4L2_DEC_CMD_PAUSE (2)
pub static V4L2_DEC_CMD_PAUSE: c_ulong = 0x2;
//#define V4L2_DEC_CMD_RESUME (3)
pub static V4L2_DEC_CMD_RESUME: c_ulong = 0x3;
//#define V4L2_DEC_CMD_START_MUTE_AUDIO (1 << 0)
pub static V4L2_DEC_CMD_START_MUTE_AUDIO: c_ulong = 0x1;
//#define V4L2_DEC_CMD_PAUSE_TO_BLACK (1 << 0)
pub static V4L2_DEC_CMD_PAUSE_TO_BLACK: c_ulong = 0x1;
//#define V4L2_DEC_CMD_STOP_TO_BLACK (1 << 0)
pub static V4L2_DEC_CMD_STOP_TO_BLACK: c_ulong = 0x1;
//#define V4L2_DEC_CMD_STOP_IMMEDIATELY (1 << 1)
pub static V4L2_DEC_CMD_STOP_IMMEDIATELY: c_ulong = 0x2;
//#define V4L2_DEC_START_FMT_NONE (0)
pub static V4L2_DEC_START_FMT_NONE: c_ulong = 0x0;
//#define V4L2_DEC_START_FMT_GOP (1)
pub static V4L2_DEC_START_FMT_GOP: c_ulong = 0x1;
//#define V4L2_VBI_UNSYNC (1 << 0)
pub static V4L2_VBI_UNSYNC: c_ulong = 0x1;
//#define V4L2_VBI_INTERLACED (1 << 1)
pub static V4L2_VBI_INTERLACED: c_ulong = 0x2;
//#define V4L2_SLICED_TELETEXT_B (0x0001)
pub static V4L2_SLICED_TELETEXT_B: c_ulong = 0x1;
//#define V4L2_SLICED_VPS (0x0400)
pub static V4L2_SLICED_VPS: c_ulong = 0x400;
//#define V4L2_SLICED_CAPTION_525 (0x1000)
pub static V4L2_SLICED_CAPTION_525: c_ulong = 0x1000;
//#define V4L2_SLICED_WSS_625 (0x4000)
pub static V4L2_SLICED_WSS_625: c_ulong = 0x4000;
//#define V4L2_SLICED_VBI_525 (V4L2_SLICED_CAPTION_525)
pub static V4L2_SLICED_VBI_525: c_ulong = 0x1000;
//#define V4L2_SLICED_VBI_625 (V4L2_SLICED_TELETEXT_B | V4L2_SLICED_VPS | V4L2_SLICED_WSS_625)
pub static V4L2_SLICED_VBI_625: c_ulong = 0x4401;
//#define V4L2_MPEG_VBI_IVTV_TELETEXT_B (1)
pub static V4L2_MPEG_VBI_IVTV_TELETEXT_B: c_ulong = 0x1;
//#define V4L2_MPEG_VBI_IVTV_CAPTION_525 (4)
pub static V4L2_MPEG_VBI_IVTV_CAPTION_525: c_ulong = 0x4;
//#define V4L2_MPEG_VBI_IVTV_WSS_625 (5)
pub static V4L2_MPEG_VBI_IVTV_WSS_625: c_ulong = 0x5;
//#define V4L2_MPEG_VBI_IVTV_VPS (7)
pub static V4L2_MPEG_VBI_IVTV_VPS: c_ulong = 0x7;
//#define V4L2_MPEG_VBI_IVTV_MAGIC0 "itv0"
pub static V4L2_MPEG_VBI_IVTV_MAGIC0: c_ulong = 0x40ca9b;
//#define V4L2_MPEG_VBI_IVTV_MAGIC1 "ITV0"
pub static V4L2_MPEG_VBI_IVTV_MAGIC1: c_ulong = 0x40caeb;
//#define V4L2_EVENT_ALL 0
pub static V4L2_EVENT_ALL: c_ulong = 0x0;
//#define V4L2_EVENT_VSYNC 1
pub static V4L2_EVENT_VSYNC: c_ulong = 0x1;
//#define V4L2_EVENT_EOS 2
pub static V4L2_EVENT_EOS: c_ulong = 0x2;
//#define V4L2_EVENT_CTRL 3
pub static V4L2_EVENT_CTRL: c_ulong = 0x3;
//#define V4L2_EVENT_FRAME_SYNC 4
pub static V4L2_EVENT_FRAME_SYNC: c_ulong = 0x4;
//#define V4L2_EVENT_PRIVATE_START 0x08000000
pub static V4L2_EVENT_PRIVATE_START: c_ulong = 0x8000000;
//#define V4L2_EVENT_CTRL_CH_VALUE (1 << 0)
pub static V4L2_EVENT_CTRL_CH_VALUE: c_ulong = 0x1;
//#define V4L2_EVENT_CTRL_CH_FLAGS (1 << 1)
pub static V4L2_EVENT_CTRL_CH_FLAGS: c_ulong = 0x2;
//#define V4L2_EVENT_SUB_FL_SEND_INITIAL (1 << 0)
pub static V4L2_EVENT_SUB_FL_SEND_INITIAL: c_ulong = 0x1;
//#define V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK (1 << 1)
pub static V4L2_EVENT_SUB_FL_ALLOW_FEEDBACK: c_ulong = 0x2;
//#define V4L2_CHIP_MATCH_HOST 0 /* Match against chip ID on host (0 for the host) */
pub static V4L2_CHIP_MATCH_HOST: c_ulong = 0x0;
//#define V4L2_CHIP_MATCH_I2C_DRIVER 1 /* Match against I2C driver name */
pub static V4L2_CHIP_MATCH_I2C_DRIVER: c_ulong = 0x1;
//#define V4L2_CHIP_MATCH_I2C_ADDR 2 /* Match against I2C 7-bit address */
pub static V4L2_CHIP_MATCH_I2C_ADDR: c_ulong = 0x2;
//#define V4L2_CHIP_MATCH_AC97 3 /* Match against anciliary AC97 chip */
pub static V4L2_CHIP_MATCH_AC97: c_ulong = 0x3;
//#define VIDIOC_QUERYCAP _IOR('V', 0, struct v4l2_capability)
pub static VIDIOC_QUERYCAP: c_ulong = 0x80685600;
//#define VIDIOC_RESERVED _IO('V', 1)
pub static VIDIOC_RESERVED: c_ulong = 0x5601;
//#define VIDIOC_ENUM_FMT _IOWR('V', 2, struct v4l2_fmtdesc)
pub static VIDIOC_ENUM_FMT: c_ulong = 0xc0405602;
//#define VIDIOC_G_FMT _IOWR('V', 4, struct v4l2_format)
pub static VIDIOC_G_FMT: c_ulong = 0xc0d05604;
//#define VIDIOC_S_FMT _IOWR('V', 5, struct v4l2_format)
pub static VIDIOC_S_FMT: c_ulong = 0xc0d05605;
//#define VIDIOC_REQBUFS _IOWR('V', 8, struct v4l2_requestbuffers)
pub static VIDIOC_REQBUFS: c_ulong = 0xc0145608;
//#define VIDIOC_QUERYBUF _IOWR('V', 9, struct v4l2_buffer)
pub static VIDIOC_QUERYBUF: c_ulong = 0xc0585609;
//#define VIDIOC_G_FBUF _IOR('V', 10, struct v4l2_framebuffer)
pub static VIDIOC_G_FBUF: c_ulong = 0x8030560a;
//#define VIDIOC_S_FBUF _IOW('V', 11, struct v4l2_framebuffer)
pub static VIDIOC_S_FBUF: c_ulong = 0x4030560b;
//#define VIDIOC_OVERLAY _IOW('V', 14, int)
pub static VIDIOC_OVERLAY: c_ulong = 0x4004560e;
//#define VIDIOC_QBUF _IOWR('V', 15, struct v4l2_buffer)
pub static VIDIOC_QBUF: c_ulong = 0xc058560f;
//#define VIDIOC_DQBUF _IOWR('V', 17, struct v4l2_buffer)
pub static VIDIOC_DQBUF: c_ulong = 0xc0585611;
//#define VIDIOC_STREAMON _IOW('V', 18, int)
pub static VIDIOC_STREAMON: c_ulong = 0x40045612;
//#define VIDIOC_STREAMOFF _IOW('V', 19, int)
pub static VIDIOC_STREAMOFF: c_ulong = 0x40045613;
//#define VIDIOC_G_PARM _IOWR('V', 21, struct v4l2_streamparm)
pub static VIDIOC_G_PARM: c_ulong = 0xc0cc5615;
//#define VIDIOC_S_PARM _IOWR('V', 22, struct v4l2_streamparm)
pub static VIDIOC_S_PARM: c_ulong = 0xc0cc5616;
//#define VIDIOC_G_STD _IOR('V', 23, v4l2_std_id)
pub static VIDIOC_G_STD: c_ulong = 0x80085617;
//#define VIDIOC_S_STD _IOW('V', 24, v4l2_std_id)
pub static VIDIOC_S_STD: c_ulong = 0x40085618;
//#define VIDIOC_ENUMSTD _IOWR('V', 25, struct v4l2_standard)
pub static VIDIOC_ENUMSTD: c_ulong = 0xc0485619;
//#define VIDIOC_ENUMINPUT _IOWR('V', 26, struct v4l2_input)
pub static VIDIOC_ENUMINPUT: c_ulong = 0xc050561a;
//#define VIDIOC_G_CTRL _IOWR('V', 27, struct v4l2_control)
pub static VIDIOC_G_CTRL: c_ulong = 0xc008561b;
//#define VIDIOC_S_CTRL _IOWR('V', 28, struct v4l2_control)
pub static VIDIOC_S_CTRL: c_ulong = 0xc008561c;
//#define VIDIOC_G_TUNER _IOWR('V', 29, struct v4l2_tuner)
pub static VIDIOC_G_TUNER: c_ulong = 0xc054561d;
//#define VIDIOC_S_TUNER _IOW('V', 30, struct v4l2_tuner)
pub static VIDIOC_S_TUNER: c_ulong = 0x4054561e;
//#define VIDIOC_G_AUDIO _IOR('V', 33, struct v4l2_audio)
pub static VIDIOC_G_AUDIO: c_ulong = 0x80345621;
//#define VIDIOC_S_AUDIO _IOW('V', 34, struct v4l2_audio)
pub static VIDIOC_S_AUDIO: c_ulong = 0x40345622;
//#define VIDIOC_QUERYCTRL _IOWR('V', 36, struct v4l2_queryctrl)
pub static VIDIOC_QUERYCTRL: c_ulong = 0xc0445624;
//#define VIDIOC_QUERYMENU _IOWR('V', 37, struct v4l2_querymenu)
pub static VIDIOC_QUERYMENU: c_ulong = 0xc02c5625;
//#define VIDIOC_G_INPUT _IOR('V', 38, int)
pub static VIDIOC_G_INPUT: c_ulong = 0x80045626;
//#define VIDIOC_S_INPUT _IOWR('V', 39, int)
pub static VIDIOC_S_INPUT: c_ulong = 0xc0045627;
//#define VIDIOC_G_OUTPUT _IOR('V', 46, int)
pub static VIDIOC_G_OUTPUT: c_ulong = 0x8004562e;
//#define VIDIOC_S_OUTPUT _IOWR('V', 47, int)
pub static VIDIOC_S_OUTPUT: c_ulong = 0xc004562f;
//#define VIDIOC_ENUMOUTPUT _IOWR('V', 48, struct v4l2_output)
pub static VIDIOC_ENUMOUTPUT: c_ulong = 0xc0485630;
//#define VIDIOC_G_AUDOUT _IOR('V', 49, struct v4l2_audioout)
pub static VIDIOC_G_AUDOUT: c_ulong = 0x80345631;
//#define VIDIOC_S_AUDOUT _IOW('V', 50, struct v4l2_audioout)
pub static VIDIOC_S_AUDOUT: c_ulong = 0x40345632;
//#define VIDIOC_G_MODULATOR _IOWR('V', 54, struct v4l2_modulator)
pub static VIDIOC_G_MODULATOR: c_ulong = 0xc0445636;
//#define VIDIOC_S_MODULATOR _IOW('V', 55, struct v4l2_modulator)
pub static VIDIOC_S_MODULATOR: c_ulong = 0x40445637;
//#define VIDIOC_G_FREQUENCY _IOWR('V', 56, struct v4l2_frequency)
pub static VIDIOC_G_FREQUENCY: c_ulong = 0xc02c5638;
//#define VIDIOC_S_FREQUENCY _IOW('V', 57, struct v4l2_frequency)
pub static VIDIOC_S_FREQUENCY: c_ulong = 0x402c5639;
//#define VIDIOC_CROPCAP _IOWR('V', 58, struct v4l2_cropcap)
pub static VIDIOC_CROPCAP: c_ulong = 0xc02c563a;
//#define VIDIOC_G_CROP _IOWR('V', 59, struct v4l2_crop)
pub static VIDIOC_G_CROP: c_ulong = 0xc014563b;
//#define VIDIOC_S_CROP _IOW('V', 60, struct v4l2_crop)
pub static VIDIOC_S_CROP: c_ulong = 0x4014563c;
//#define VIDIOC_G_JPEGCOMP _IOR('V', 61, struct v4l2_jpegcompression)
pub static VIDIOC_G_JPEGCOMP: c_ulong = 0x808c563d;
//#define VIDIOC_S_JPEGCOMP _IOW('V', 62, struct v4l2_jpegcompression)
pub static VIDIOC_S_JPEGCOMP: c_ulong = 0x408c563e;
//#define VIDIOC_QUERYSTD _IOR('V', 63, v4l2_std_id)
pub static VIDIOC_QUERYSTD: c_ulong = 0x8008563f;
//#define VIDIOC_TRY_FMT _IOWR('V', 64, struct v4l2_format)
pub static VIDIOC_TRY_FMT: c_ulong = 0xc0d05640;
//#define VIDIOC_ENUMAUDIO _IOWR('V', 65, struct v4l2_audio)
pub static VIDIOC_ENUMAUDIO: c_ulong = 0xc0345641;
//#define VIDIOC_ENUMAUDOUT _IOWR('V', 66, struct v4l2_audioout)
pub static VIDIOC_ENUMAUDOUT: c_ulong = 0xc0345642;
//#define VIDIOC_G_PRIORITY _IOR('V', 67, __u32) /* enum v4l2_priority */
pub static VIDIOC_G_PRIORITY: c_ulong = 0x80045643;
//#define VIDIOC_S_PRIORITY _IOW('V', 68, __u32) /* enum v4l2_priority */
pub static VIDIOC_S_PRIORITY: c_ulong = 0x40045644;
//#define VIDIOC_G_SLICED_VBI_CAP _IOWR('V', 69, struct v4l2_sliced_vbi_cap)
pub static VIDIOC_G_SLICED_VBI_CAP: c_ulong = 0xc0745645;
//#define VIDIOC_LOG_STATUS _IO('V', 70)
pub static VIDIOC_LOG_STATUS: c_ulong = 0x5646;
//#define VIDIOC_G_EXT_CTRLS _IOWR('V', 71, struct v4l2_ext_controls)
pub static VIDIOC_G_EXT_CTRLS: c_ulong = 0xc0205647;
//#define VIDIOC_S_EXT_CTRLS _IOWR('V', 72, struct v4l2_ext_controls)
pub static VIDIOC_S_EXT_CTRLS: c_ulong = 0xc0205648;
//#define VIDIOC_TRY_EXT_CTRLS _IOWR('V', 73, struct v4l2_ext_controls)
pub static VIDIOC_TRY_EXT_CTRLS: c_ulong = 0xc0205649;
//#define VIDIOC_ENUM_FRAMESIZES _IOWR('V', 74, struct v4l2_frmsizeenum)
pub static VIDIOC_ENUM_FRAMESIZES: c_ulong = 0xc02c564a;
//#define VIDIOC_ENUM_FRAMEINTERVALS _IOWR('V', 75, struct v4l2_frmivalenum)
pub static VIDIOC_ENUM_FRAMEINTERVALS: c_ulong = 0xc034564b;
//#define VIDIOC_G_ENC_INDEX _IOR('V', 76, struct v4l2_enc_idx)
pub static VIDIOC_G_ENC_INDEX: c_ulong = 0x8818564c;
//#define VIDIOC_ENCODER_CMD _IOWR('V', 77, struct v4l2_encoder_cmd)
pub static VIDIOC_ENCODER_CMD: c_ulong = 0xc028564d;
//#define VIDIOC_TRY_ENCODER_CMD _IOWR('V', 78, struct v4l2_encoder_cmd)
pub static VIDIOC_TRY_ENCODER_CMD: c_ulong = 0xc028564e;
//#define VIDIOC_DBG_S_REGISTER _IOW('V', 79, struct v4l2_dbg_register)
pub static VIDIOC_DBG_S_REGISTER: c_ulong = 0x4038564f;
//#define VIDIOC_DBG_G_REGISTER _IOWR('V', 80, struct v4l2_dbg_register)
pub static VIDIOC_DBG_G_REGISTER: c_ulong = 0xc0385650;
//#define VIDIOC_DBG_G_CHIP_IDENT _IOWR('V', 81, struct v4l2_dbg_chip_ident)
pub static VIDIOC_DBG_G_CHIP_IDENT: c_ulong = 0xc02c5651;
//#define VIDIOC_S_HW_FREQ_SEEK _IOW('V', 82, struct v4l2_hw_freq_seek)
pub static VIDIOC_S_HW_FREQ_SEEK: c_ulong = 0x40305652;
//#define VIDIOC_ENUM_DV_PRESETS _IOWR('V', 83, struct v4l2_dv_enum_preset)
pub static VIDIOC_ENUM_DV_PRESETS: c_ulong = 0xc0405653;
//#define VIDIOC_S_DV_PRESET _IOWR('V', 84, struct v4l2_dv_preset)
pub static VIDIOC_S_DV_PRESET: c_ulong = 0xc0145654;
//#define VIDIOC_G_DV_PRESET _IOWR('V', 85, struct v4l2_dv_preset)
pub static VIDIOC_G_DV_PRESET: c_ulong = 0xc0145655;
//#define VIDIOC_QUERY_DV_PRESET _IOR('V', 86, struct v4l2_dv_preset)
pub static VIDIOC_QUERY_DV_PRESET: c_ulong = 0x80145656;
//#define VIDIOC_S_DV_TIMINGS _IOWR('V', 87, struct v4l2_dv_timings)
pub static VIDIOC_S_DV_TIMINGS: c_ulong = 0xc0845657;
//#define VIDIOC_G_DV_TIMINGS _IOWR('V', 88, struct v4l2_dv_timings)
pub static VIDIOC_G_DV_TIMINGS: c_ulong = 0xc0845658;
//#define VIDIOC_DQEVENT _IOR('V', 89, struct v4l2_event)
pub static VIDIOC_DQEVENT: c_ulong = 0x80885659;
//#define VIDIOC_SUBSCRIBE_EVENT _IOW('V', 90, struct v4l2_event_subscription)
pub static VIDIOC_SUBSCRIBE_EVENT: c_ulong = 0x4020565a;
//#define VIDIOC_UNSUBSCRIBE_EVENT _IOW('V', 91, struct v4l2_event_subscription)
pub static VIDIOC_UNSUBSCRIBE_EVENT: c_ulong = 0x4020565b;
//#define VIDIOC_CREATE_BUFS _IOWR('V', 92, struct v4l2_create_buffers)
pub static VIDIOC_CREATE_BUFS: c_ulong = 0xc100565c;
//#define VIDIOC_PREPARE_BUF _IOWR('V', 93, struct v4l2_buffer)
pub static VIDIOC_PREPARE_BUF: c_ulong = 0xc058565d;
//#define VIDIOC_G_SELECTION _IOWR('V', 94, struct v4l2_selection)
pub static VIDIOC_G_SELECTION: c_ulong = 0xc040565e;
//#define VIDIOC_S_SELECTION _IOWR('V', 95, struct v4l2_selection)
pub static VIDIOC_S_SELECTION: c_ulong = 0xc040565f;
//#define VIDIOC_DECODER_CMD _IOWR('V', 96, struct v4l2_decoder_cmd)
pub static VIDIOC_DECODER_CMD: c_ulong = 0xc0485660;
//#define VIDIOC_TRY_DECODER_CMD _IOWR('V', 97, struct v4l2_decoder_cmd)
pub static VIDIOC_TRY_DECODER_CMD: c_ulong = 0xc0485661;
//#define VIDIOC_ENUM_DV_TIMINGS _IOWR('V', 98, struct v4l2_enum_dv_timings)
pub static VIDIOC_ENUM_DV_TIMINGS: c_ulong = 0xc0945662;
//#define VIDIOC_QUERY_DV_TIMINGS _IOR('V', 99, struct v4l2_dv_timings)
pub static VIDIOC_QUERY_DV_TIMINGS: c_ulong = 0x80845663;
//#define VIDIOC_DV_TIMINGS_CAP _IOWR('V', 100, struct v4l2_dv_timings_cap)
pub static VIDIOC_DV_TIMINGS_CAP: c_ulong = 0xc0905664;
//#define VIDIOC_ENUM_FREQ_BANDS _IOWR('V', 101, struct v4l2_frequency_band)
pub static VIDIOC_ENUM_FREQ_BANDS: c_ulong = 0xc0405665;
//#define BASE_VIDIOC_PRIVATE 192 /* 192-255 are private */
pub static BASE_VIDIOC_PRIVATE: c_ulong = 0xc0;

pub type v4l2_field = c_uint;
pub static V4L2_FIELD_ANY: c_uint = 0;
pub static V4L2_FIELD_NONE: c_uint = 1;
pub static V4L2_FIELD_TOP: c_uint = 2;
pub static V4L2_FIELD_BOTTOM: c_uint = 3;
pub static V4L2_FIELD_INTERLACED: c_uint = 4;
pub static V4L2_FIELD_SEQ_TB: c_uint = 5;
pub static V4L2_FIELD_SEQ_BT: c_uint = 6;
pub static V4L2_FIELD_ALTERNATE: c_uint = 7;
pub static V4L2_FIELD_INTERLACED_TB: c_uint = 8;
pub static V4L2_FIELD_INTERLACED_BT: c_uint = 9;
pub type v4l2_buf_type = c_uint;
pub static V4L2_BUF_TYPE_VIDEO_CAPTURE: c_uint = 1;
pub static V4L2_BUF_TYPE_VIDEO_OUTPUT: c_uint = 2;
pub static V4L2_BUF_TYPE_VIDEO_OVERLAY: c_uint = 3;
pub static V4L2_BUF_TYPE_VBI_CAPTURE: c_uint = 4;
pub static V4L2_BUF_TYPE_VBI_OUTPUT: c_uint = 5;
pub static V4L2_BUF_TYPE_SLICED_VBI_CAPTURE: c_uint = 6;
pub static V4L2_BUF_TYPE_SLICED_VBI_OUTPUT: c_uint = 7;
pub static V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY: c_uint = 8;
pub static V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE: c_uint = 9;
pub static V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE: c_uint = 10;
pub static V4L2_BUF_TYPE_PRIVATE: c_uint = 128;
pub type v4l2_tuner_type = c_uint;
pub static V4L2_TUNER_RADIO: c_uint = 1;
pub static V4L2_TUNER_ANALOG_TV: c_uint = 2;
pub static V4L2_TUNER_DIGITAL_TV: c_uint = 3;
pub type v4l2_memory = c_uint;
pub static V4L2_MEMORY_MMAP: c_uint = 1;
pub static V4L2_MEMORY_USERPTR: c_uint = 2;
pub static V4L2_MEMORY_OVERLAY: c_uint = 3;
pub type v4l2_colorspace = c_uint;
pub static V4L2_COLORSPACE_SMPTE170M: c_uint = 1;
pub static V4L2_COLORSPACE_SMPTE240M: c_uint = 2;
pub static V4L2_COLORSPACE_REC709: c_uint = 3;
pub static V4L2_COLORSPACE_BT878: c_uint = 4;
pub static V4L2_COLORSPACE_470_SYSTEM_M: c_uint = 5;
pub static V4L2_COLORSPACE_470_SYSTEM_BG: c_uint = 6;
pub static V4L2_COLORSPACE_JPEG: c_uint = 7;
pub static V4L2_COLORSPACE_SRGB: c_uint = 8;
pub type v4l2_priority = c_uint;
pub static V4L2_PRIORITY_UNSET: c_uint = 0;
pub static V4L2_PRIORITY_BACKGROUND: c_uint = 1;
pub static V4L2_PRIORITY_INTERACTIVE: c_uint = 2;
pub static V4L2_PRIORITY_RECORD: c_uint = 3;
pub static V4L2_PRIORITY_DEFAULT: c_uint = 2;
pub struct v4l2_rect {
    left: i32,
    top: i32,
    width: i32,
    height: i32,
}
pub struct v4l2_fract {
    numerator: u32,
    denominator: u32,
}
pub struct v4l2_capability {
    driver: [u8, ..16u],
    card: [u8, ..32u],
    bus_info: [u8, ..32u],
    version: u32,
    capabilities: u32,
    device_caps: u32,
    reserved: [u32, ..3u],
}
impl Default for v4l2_capability {
    fn default() -> v4l2_capability {
        v4l2_capability {
            driver: [0, ..16u],
            card: [0, ..32u],
            bus_info: [0, ..32u],
            version: 0,
            capabilities: 0,
            device_caps: 0,
            reserved: [0, ..3u],
        }
    }
}
pub struct v4l2_pix_format {
    width: u32,
    height: u32,
    pixelformat: u32,
    field: u32,
    bytesperline: u32,
    sizeimage: u32,
    colorspace: u32,
    _priv: u32,
}
pub struct v4l2_fmtdesc {
    index: u32,
    _type: u32,
    flags: u32,
    description: [u8, ..32u],
    pixelformat: u32,
    reserved: [u32, ..4u],
}
pub type v4l2_frmsizetypes = c_uint;
pub static V4L2_FRMSIZE_TYPE_DISCRETE: c_uint = 1;
pub static V4L2_FRMSIZE_TYPE_CONTINUOUS: c_uint = 2;
pub static V4L2_FRMSIZE_TYPE_STEPWISE: c_uint = 3;
pub struct v4l2_frmsize_discrete {
    width: u32,
    height: u32,
}
pub struct v4l2_frmsize_stepwise {
    min_width: u32,
    max_width: u32,
    step_width: u32,
    min_height: u32,
    max_height: u32,
    step_height: u32,
}
pub struct v4l2_frmsizeenum {
    index: u32,
    pixel_format: u32,
    _type: u32,
    reserved: [u32, ..2u],
}
pub struct union1 {
    data: [u32, ..6u],
}
impl union1 {
    pub fn discrete(&mut self) -> *mut v4l2_frmsize_discrete {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn stepwise(&mut self) -> *mut v4l2_frmsize_stepwise {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type v4l2_frmivaltypes = c_uint;
pub static V4L2_FRMIVAL_TYPE_DISCRETE: c_uint = 1;
pub static V4L2_FRMIVAL_TYPE_CONTINUOUS: c_uint = 2;
pub static V4L2_FRMIVAL_TYPE_STEPWISE: c_uint = 3;
pub struct v4l2_frmival_stepwise {
    min: v4l2_fract,
    max: v4l2_fract,
    step: v4l2_fract,
}
pub struct v4l2_frmivalenum {
    index: u32,
    pixel_format: u32,
    width: u32,
    height: u32,
    _type: u32,
    reserved: [u32, ..2u],
}
pub struct union2 {
    data: [u32, ..6u],
}
impl union2 {
    pub fn discrete(&mut self) -> *mut v4l2_fract {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn stepwise(&mut self) -> *mut v4l2_frmival_stepwise {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_timecode {
    _type: u32,
    flags: u32,
    frames: u8,
    seconds: u8,
    minutes: u8,
    hours: u8,
    userbits: [u8, ..4u],
}
pub struct v4l2_jpegcompression {
    quality: c_int,
    APPn: c_int,
    APP_len: c_int,
    APP_data: [c_schar, ..60u],
    COM_len: c_int,
    COM_data: [c_schar, ..60u],
    jpeg_markers: u32,
}
pub struct v4l2_requestbuffers {
    count: u32,
    _type: u32,
    memory: u32,
    reserved: [u32, ..2u],
}
pub struct v4l2_plane {
    bytesused: u32,
    length: u32,
    m: union3,
    data_offset: u32,
    reserved: [u32, ..11u],
}
pub struct union3 {
    data: [u64, ..1u],
}
impl union3 {
    pub fn mem_offset(&mut self) -> *mut u32 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn userptr(&mut self) -> *mut c_ulong {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_buffer {
    index: u32,
    _type: u32,
    bytesused: u32,
    flags: u32,
    field: u32,
    timestamp: timeval,
    timecode: v4l2_timecode,
    sequence: u32,
    memory: u32,
    m: union4,
    length: u32,
    reserved2: u32,
    reserved: u32,
}
pub struct union4 {
    data: [u64, ..1u],
}
impl union4 {
    pub fn offset(&mut self) -> *mut u32 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn userptr(&mut self) -> *mut c_ulong {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn planes(&mut self) -> *mut *mut v4l2_plane {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_framebuffer {
    capability: u32,
    flags: u32,
    base: *mut c_void,
    fmt: v4l2_pix_format,
}
pub struct v4l2_clip {
    c: v4l2_rect,
    next: *mut v4l2_clip,
}
pub struct v4l2_window {
    w: v4l2_rect,
    field: u32,
    chromakey: u32,
    clips: *mut v4l2_clip,
    clipcount: u32,
    bitmap: *mut c_void,
    global_alpha: u8,
}
pub struct v4l2_captureparm {
    capability: u32,
    capturemode: u32,
    timeperframe: v4l2_fract,
    extendedmode: u32,
    readbuffers: u32,
    reserved: [u32, ..4u],
}
pub struct v4l2_outputparm {
    capability: u32,
    outputmode: u32,
    timeperframe: v4l2_fract,
    extendedmode: u32,
    writebuffers: u32,
    reserved: [u32, ..4u],
}
pub struct v4l2_cropcap {
    _type: u32,
    bounds: v4l2_rect,
    defrect: v4l2_rect,
    pixelaspect: v4l2_fract,
}
pub struct v4l2_crop {
    _type: u32,
    c: v4l2_rect,
}
pub struct v4l2_selection {
    _type: u32,
    target: u32,
    flags: u32,
    r: v4l2_rect,
    reserved: [u32, ..9u],
}
pub type v4l2_std_id = u64;
pub struct v4l2_standard {
    index: u32,
    id: v4l2_std_id,
    name: [u8, ..24u],
    frameperiod: v4l2_fract,
    framelines: u32,
    reserved: [u32, ..4u],
}
pub struct v4l2_dv_preset {
    preset: u32,
    reserved: [u32, ..4u],
}
pub struct v4l2_dv_enum_preset {
    index: u32,
    preset: u32,
    name: [u8, ..32u],
    width: u32,
    height: u32,
    reserved: [u32, ..4u],
}
pub struct v4l2_bt_timings {
    width: u32,
    height: u32,
    interlaced: u32,
    polarities: u32,
    pixelclock: u64,
    hfrontporch: u32,
    hsync: u32,
    hbackporch: u32,
    vfrontporch: u32,
    vsync: u32,
    vbackporch: u32,
    il_vfrontporch: u32,
    il_vsync: u32,
    il_vbackporch: u32,
    standards: u32,
    flags: u32,
    reserved: [u32, ..14u],
}
pub struct v4l2_dv_timings {
    _type: u32,
}
pub struct union5 {
    data: [u32, ..32u],
}
impl union5 {
    pub fn bt(&mut self) -> *mut v4l2_bt_timings {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn reserved(&mut self) -> *mut [u32, ..32u] {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_enum_dv_timings {
    index: u32,
    reserved: [u32, ..3u],
    timings: v4l2_dv_timings,
}
pub struct v4l2_bt_timings_cap {
    min_width: u32,
    max_width: u32,
    min_height: u32,
    max_height: u32,
    min_pixelclock: u64,
    max_pixelclock: u64,
    standards: u32,
    capabilities: u32,
    reserved: [u32, ..16u],
}
pub struct v4l2_dv_timings_cap {
    _type: u32,
    reserved: [u32, ..3u],
}
pub struct union6 {
    data: [u32, ..32u],
}
impl union6 {
    pub fn bt(&mut self) -> *mut v4l2_bt_timings_cap {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn raw_data(&mut self) -> *mut [u32, ..32u] {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_input {
    index: u32,
    name: [u8, ..32u],
    _type: u32,
    audioset: u32,
    tuner: u32,
    std: v4l2_std_id,
    status: u32,
    capabilities: u32,
    reserved: [u32, ..3u],
}
pub struct v4l2_output {
    index: u32,
    name: [u8, ..32u],
    _type: u32,
    audioset: u32,
    modulator: u32,
    std: v4l2_std_id,
    capabilities: u32,
    reserved: [u32, ..3u],
}
pub struct v4l2_control {
    id: u32,
    value: i32,
}
pub struct v4l2_ext_control {
    id: u32,
    size: u32,
    reserved2: [u32, ..1u],
}
pub struct union7 {
    data: [u64, ..1u],
}
impl union7 {
    pub fn value(&mut self) -> *mut i32 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn value64(&mut self) -> *mut i64 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn string(&mut self) -> *mut *mut c_schar {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_ext_controls {
    ctrl_class: u32,
    count: u32,
    error_idx: u32,
    reserved: [u32, ..2u],
    controls: *mut v4l2_ext_control,
}
pub type v4l2_ctrl_type = c_uint;
pub static V4L2_CTRL_TYPE_INTEGER: c_uint = 1;
pub static V4L2_CTRL_TYPE_BOOLEAN: c_uint = 2;
pub static V4L2_CTRL_TYPE_MENU: c_uint = 3;
pub static V4L2_CTRL_TYPE_BUTTON: c_uint = 4;
pub static V4L2_CTRL_TYPE_INTEGER64: c_uint = 5;
pub static V4L2_CTRL_TYPE_CTRL_CLASS: c_uint = 6;
pub static V4L2_CTRL_TYPE_STRING: c_uint = 7;
pub static V4L2_CTRL_TYPE_BITMASK: c_uint = 8;
pub static V4L2_CTRL_TYPE_INTEGER_MENU: c_uint = 9;
pub struct v4l2_queryctrl {
    id: u32,
    _type: u32,
    name: [u8, ..32u],
    minimum: i32,
    maximum: i32,
    step: i32,
    default_value: i32,
    flags: u32,
    reserved: [u32, ..2u],
}
pub struct v4l2_querymenu {
    id: u32,
    index: u32,
    reserved: u32,
}
pub struct union8 {
    data: [u64, ..4u],
}
impl union8 {
    pub fn name(&mut self) -> *mut [u8, ..32u] {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn value(&mut self) -> *mut i64 {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub type v4l2_dv_tx_mode = c_uint;
pub static V4L2_DV_TX_MODE_DVI_D: c_uint = 0;
pub static V4L2_DV_TX_MODE_HDMI: c_uint = 1;
pub type v4l2_dv_rgb_range = c_uint;
pub static V4L2_DV_RGB_RANGE_AUTO: c_uint = 0;
pub static V4L2_DV_RGB_RANGE_LIMITED: c_uint = 1;
pub static V4L2_DV_RGB_RANGE_FULL: c_uint = 2;
pub struct v4l2_tuner {
    index: u32,
    name: [u8, ..32u],
    _type: u32,
    capability: u32,
    rangelow: u32,
    rangehigh: u32,
    rxsubchans: u32,
    audmode: u32,
    signal: i32,
    afc: i32,
    reserved: [u32, ..4u],
}
pub struct v4l2_modulator {
    index: u32,
    name: [u8, ..32u],
    capability: u32,
    rangelow: u32,
    rangehigh: u32,
    txsubchans: u32,
    reserved: [u32, ..4u],
}
pub struct v4l2_frequency {
    tuner: u32,
    _type: u32,
    frequency: u32,
    reserved: [u32, ..8u],
}
pub struct v4l2_frequency_band {
    tuner: u32,
    _type: u32,
    index: u32,
    capability: u32,
    rangelow: u32,
    rangehigh: u32,
    modulation: u32,
    reserved: [u32, ..9u],
}
pub struct v4l2_hw_freq_seek {
    tuner: u32,
    _type: u32,
    seek_upward: u32,
    wrap_around: u32,
    spacing: u32,
    rangelow: u32,
    rangehigh: u32,
    reserved: [u32, ..5u],
}
pub struct v4l2_rds_data {
    lsb: u8,
    msb: u8,
    block: u8,
}
pub struct v4l2_audio {
    index: u32,
    name: [u8, ..32u],
    capability: u32,
    mode: u32,
    reserved: [u32, ..2u],
}
pub struct v4l2_audioout {
    index: u32,
    name: [u8, ..32u],
    capability: u32,
    mode: u32,
    reserved: [u32, ..2u],
}
pub struct v4l2_enc_idx_entry {
    offset: u64,
    pts: u64,
    length: u32,
    flags: u32,
    reserved: [u32, ..2u],
}
pub struct v4l2_enc_idx {
    entries: u32,
    entries_cap: u32,
    reserved: [u32, ..4u],
    entry: [v4l2_enc_idx_entry, ..64u],
}
pub struct v4l2_encoder_cmd {
    cmd: u32,
    flags: u32,
}
pub struct union9 {
    data: [u32, ..8u],
}
impl union9 {
    pub fn raw(&mut self) -> *mut union10 {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct union10 {
    data: [u32, ..8u],
}
pub struct v4l2_decoder_cmd {
    cmd: u32,
    flags: u32,
}
pub struct union11 {
    data: [u64, ..8u],
}
impl union11 {
    pub fn stop(&mut self) -> *mut union12 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn start(&mut self) -> *mut union13 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn raw(&mut self) -> *mut union14 {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct union12 {
    pts: u64,
}
pub struct union13 {
    speed: i32,
    format: u32,
}
pub struct union14 {
    data: [u32, ..16u],
}
pub struct v4l2_vbi_format {
    sampling_rate: u32,
    offset: u32,
    samples_per_line: u32,
    sample_format: u32,
    start: [i32, ..2u],
    count: [u32, ..2u],
    flags: u32,
    reserved: [u32, ..2u],
}
pub struct v4l2_sliced_vbi_format {
    service_set: u16,
    service_lines: [[u16, ..24u], ..2u],
    io_size: u32,
    reserved: [u32, ..2u],
}
pub struct v4l2_sliced_vbi_cap {
    service_set: u16,
    service_lines: [[u16, ..24u], ..2u],
    _type: u32,
    reserved: [u32, ..3u],
}
pub struct v4l2_sliced_vbi_data {
    id: u32,
    field: u32,
    line: u32,
    reserved: u32,
    data: [u8, ..48u],
}
pub struct v4l2_mpeg_vbi_itv0_line {
    id: u8,
    data: [u8, ..42u],
}
pub struct v4l2_mpeg_vbi_itv0 {
    linemask: [u32, ..2u],
    line: [v4l2_mpeg_vbi_itv0_line, ..35u],
}
pub struct v4l2_mpeg_vbi_ITV0 {
    line: [v4l2_mpeg_vbi_itv0_line, ..36u],
}
pub struct v4l2_mpeg_vbi_fmt_ivtv {
    magic: [u8, ..4u],
}
pub struct union15 {
    data: [u8, ..1548u],
}
impl union15 {
    pub fn itv0(&mut self) -> *mut v4l2_mpeg_vbi_itv0 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn ITV0(&mut self) -> *mut v4l2_mpeg_vbi_ITV0 {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_plane_pix_format {
    sizeimage: u32,
    bytesperline: u16,
    reserved: [u16, ..7u],
}
pub struct v4l2_pix_format_mplane {
    width: u32,
    height: u32,
    pixelformat: u32,
    field: u32,
    colorspace: u32,
    plane_fmt: [v4l2_plane_pix_format, ..8u],
    num_planes: u8,
    reserved: [u8, ..11u],
}
pub struct v4l2_format {
    _type: u32,
    fmt: union16,
}
pub struct union16 {
    data: [u64, ..25u],
}
impl union16 {
    pub fn pix(&mut self) -> *mut v4l2_pix_format {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn pix_mp(&mut self) -> *mut v4l2_pix_format_mplane {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn win(&mut self) -> *mut v4l2_window {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn vbi(&mut self) -> *mut v4l2_vbi_format {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn sliced(&mut self) -> *mut v4l2_sliced_vbi_format {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn raw_data(&mut self) -> *mut [u8, ..200u] {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_streamparm {
    _type: u32,
    parm: union17,
}
pub struct union17 {
    data: [u32, ..50u],
}
impl union17 {
    pub fn capture(&mut self) -> *mut v4l2_captureparm {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn output(&mut self) -> *mut v4l2_outputparm {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn raw_data(&mut self) -> *mut [u8, ..200u] {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_event_vsync {
    field: u8,
}
pub struct v4l2_event_ctrl {
    changes: u32,
    _type: u32,
    flags: u32,
    minimum: i32,
    maximum: i32,
    step: i32,
    default_value: i32,
}
pub struct union18 {
    data: [u64, ..1u],
}
impl union18 {
    pub fn value(&mut self) -> *mut i32 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn value64(&mut self) -> *mut i64 {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_event_frame_sync {
    frame_sequence: u32,
}
pub struct v4l2_event {
    _type: u32,
    u: union19,
    pending: u32,
    sequence: u32,
    timestamp: timespec,
    id: u32,
    reserved: [u32, ..8u],
}
pub struct union19 {
    data: [u64, ..8u],
}
impl union19 {
    pub fn vsync(&mut self) -> *mut v4l2_event_vsync {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn ctrl(&mut self) -> *mut v4l2_event_ctrl {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn frame_sync(&mut self) -> *mut v4l2_event_frame_sync {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn data(&mut self) -> *mut [u8, ..64u] {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_event_subscription {
    _type: u32,
    id: u32,
    flags: u32,
    reserved: [u32, ..5u],
}
pub struct v4l2_dbg_match {
    _type: u32,
}
pub struct union20 {
    data: [u32, ..8u],
}
impl union20 {
    pub fn addr(&mut self) -> *mut u32 {
        unsafe { ::std::cast::transmute(self) }
    }
    pub fn name(&mut self) -> *mut [c_schar, ..32u] {
        unsafe { ::std::cast::transmute(self) }
    }
}
pub struct v4l2_dbg_register {
    _match: v4l2_dbg_match,
    size: u32,
    reg: u64,
    val: u64,
}
pub struct v4l2_dbg_chip_ident {
    _match: v4l2_dbg_match,
    ident: u32,
    revision: u32,
}
pub struct v4l2_create_buffers {
    index: u32,
    count: u32,
    memory: u32,
    format: v4l2_format,
    reserved: [u32, ..8u],
}
#[link(name = "xioctl")]
extern {
    pub fn xioctl(fd: c_int, req: c_ulong, arg: *mut c_void) -> c_int;
}
